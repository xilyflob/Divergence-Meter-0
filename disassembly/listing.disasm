Disassembly Listing for F18444_Rebuild
Generated From:
D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/dist/default/debug/F18444_Rebuild.X.debug.elf
May 26, 2021 4:47:39 PM

---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/tmr4.c  --
1:             /**
2:               TMR4 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr4.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR4 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR4.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16F18444
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above 
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr4.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            void (*TMR4_InterruptHandler)(void);
59:            
60:            /**
61:              Section: TMR4 APIs
62:            */
63:            
64:            void TMR4_Initialize(void)
65:            {
66:                // Set TMR4 to the options selected in the User Interface
67:            
68:                // T4CS HFINTOSC; 
69:                T4CLKCON = 0x03;
0BDD  3003     MOVLW 0x3
0BDE  0145     MOVLB 0x5
0BDF  0096     MOVWF T4CLKCON
70:            
71:                // T4PSYNC Not Synchronized; T4MODE Software control; T4CKPOL Rising Edge; T4CKSYNC Synchronized; 
72:                T4HLT = 0x20;
0BE0  3020     MOVLW 0x20
0BE1  0095     MOVWF T4HLT
73:            
74:                // T4RSEL T4CKIPPS pin; 
75:                T4RST = 0x00;
0BE2  0197     CLRF T4RST
76:            
77:                // T4PR 249; 
78:                T4PR = 0xF9;
0BE3  30F9     MOVLW 0xF9
0BE4  0093     MOVWF T4PR
79:            
80:                // TMR4 0; 
81:                T4TMR = 0x00;
0BE5  0192     CLRF T4TMR
82:            
83:                // Clearing IF flag before enabling the interrupt.
84:                PIR4bits.TMR4IF = 0;
0BE6  014E     MOVLB 0xE
0BE7  1190     BCF PIR4, 0x3
85:            
86:                // Enabling TMR4 interrupt.
87:                PIE4bits.TMR4IE = 1;
0BE8  159A     BSF PIE4, 0x3
88:            
89:                // Set Default Interrupt Handler
90:                TMR4_SetInterruptHandler(TMR4_DefaultInterruptHandler);
0BE9  3001     MOVLW 0x1
0BEA  00F1     MOVWF 0x771
0BEB  300A     MOVLW 0xA
0BEC  00F2     MOVWF 0x772
0BED  318A     MOVLP 0xA
0BEE  2221     CALL 0x221
91:            
92:                // T4CKPS 1:16; T4OUTPS 1:1; TMR4ON off; 
93:                T4CON = 0x40;
0BEF  3040     MOVLW 0x40
0BF0  0145     MOVLB 0x5
0BF1  0094     MOVWF T4CON
94:            }
0BF2  0008     RETURN
95:            
96:            void TMR4_ModeSet(TMR4_HLT_MODE mode)
97:            {
98:               // Configure different types HLT mode
99:                T4HLTbits.MODE = mode;
100:           }
101:           
102:           void TMR4_ExtResetSourceSet(TMR4_HLT_EXT_RESET_SOURCE reset)
103:           {
104:               //Configure different types of HLT external reset source
105:               T4RSTbits.RSEL = reset;
106:           }
107:           
108:           void TMR4_Start(void)
109:           {
110:               // Start the Timer by writing to TMRxON bit
111:               T4CONbits.TMR4ON = 1;
09B3  0145     MOVLB 0x5
09B4  1794     BSF T4CON, 0x7
112:           }
09B5  0008     RETURN
113:           
114:           void TMR4_StartTimer(void)
115:           {
116:               TMR4_Start();
117:           }
118:           
119:           void TMR4_Stop(void)
120:           {
121:               // Stop the Timer by writing to TMRxON bit
122:               T4CONbits.TMR4ON = 0;
09B6  0145     MOVLB 0x5
09B7  1394     BCF T4CON, 0x7
123:           }
09B8  0008     RETURN
124:           
125:           void TMR4_StopTimer(void)
126:           {
127:               TMR4_Stop();
128:           }
129:           
130:           uint8_t TMR4_Counter8BitGet(void)
131:           {
132:               uint8_t readVal;
133:           
134:               readVal = TMR4;
135:           
136:               return readVal;
137:           }
138:           
139:           uint8_t TMR4_ReadTimer(void)
140:           {
141:               return TMR4_Counter8BitGet();
142:           }
143:           
144:           void TMR4_Counter8BitSet(uint8_t timerVal)
145:           {
146:               // Write to the Timer4 register
147:               TMR4 = timerVal;
148:           }
149:           
150:           void TMR4_WriteTimer(uint8_t timerVal)
151:           {
152:               TMR4_Counter8BitSet(timerVal);
153:           }
154:           
155:           void TMR4_Period8BitSet(uint8_t periodVal)
156:           {
157:              PR4 = periodVal;
158:           }
159:           
160:           void TMR4_LoadPeriodRegister(uint8_t periodVal)
161:           {
162:              TMR4_Period8BitSet(periodVal);
163:           }
164:           
165:           void TMR4_ISR(void)
166:           {
167:           
168:               // clear the TMR4 interrupt flag
169:               PIR4bits.TMR4IF = 0;
09D1  1190     BCF T2CLKCON, 0x3
170:           
171:               // ticker function call;
172:               // ticker is 1 -> Callback function gets called everytime this ISR executes
173:               TMR4_CallBack();
09D2  318A     MOVLP 0xA
09D3  2281     CALL 0x281
174:           }
09D4  0008     RETURN
175:           
176:           void TMR4_CallBack(void)
177:           {
178:               // Add your custom callback code here
179:               // this code executes every TMR4_INTERRUPT_TICKER_FACTOR periods of TMR4
180:               if(TMR4_InterruptHandler)
0A81  0140     MOVLB 0x0
0A82  082C     MOVF TMR4_InterruptHandler, W
0A83  042D     IORWF 0x2D, W
0A84  1903     BTFSC STATUS, 0x2
0A85  0008     RETURN
181:               {
182:                   TMR4_InterruptHandler();
0A86  082D     MOVF 0x2D, W
0A87  008A     MOVWF PCLATH
0A88  082C     MOVF TMR4_InterruptHandler, W
0A89  000A     CALLW
0A8A  318A     MOVLP 0xA
183:               }
184:           }
0A8B  0008     RETURN
185:           
186:           void TMR4_SetInterruptHandler(void (* InterruptHandler)(void)){
187:               TMR4_InterruptHandler = InterruptHandler;
0A21  0872     MOVF input, W
0A22  0140     MOVLB 0x0
0A23  00AD     MOVWF 0x2D
0A24  0871     MOVF data, W
0A25  00AC     MOVWF TMR4_InterruptHandler
188:           }
0A26  0008     RETURN
189:           
190:           void TMR4_DefaultInterruptHandler(void){
191:               // add your TMR4 interrupt custom code
192:               // or set custom function using TMR4_SetInterruptHandler()
193:               extern uint16_t buttoncounter;
194:               buttoncounter++;
0A01  3001     MOVLW 0x1
0A02  07AE     ADDWF buttoncounter, F
0A03  3000     MOVLW 0x0
0A04  3DAF     ADDWFC 0x2F, F
195:           }
0A05  0008     RETURN
196:           
197:           /**
198:             End of File
199:           */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/tmr2.c  --
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16F18444
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above 
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
0AF9  3001     MOVLW 0x1
0AFA  0090     MOVWF 0x10
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Synchronized; 
70:                T2HLT = 0x20;
0AFB  3020     MOVLW 0x20
0AFC  008F     MOVWF 0xF
71:            
72:                // T2RSEL T2CKIPPS pin; 
73:                T2RST = 0x00;
0AFD  0191     CLRF 0x11
74:            
75:                // T2PR 129; 
76:                T2PR = 0x81;
0AFE  3081     MOVLW 0x81
0AFF  008D     MOVWF PORTB
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
0B00  018C     CLRF PORTA
80:            
81:                // Clearing IF flag.
82:                PIR4bits.TMR2IF = 0;
0B01  014E     MOVLB 0xE
0B02  1090     BCF PIR4, 0x1
83:            
84:                // T2CKPS 1:4; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0xA0;
0B03  30A0     MOVLW 0xA0
0B04  0145     MOVLB 0x5
0B05  008E     MOVWF T2CON
86:            }
0B06  0008     RETURN
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR4bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:               PIR4bits.TMR2IF = 0;
165:           }
166:               return status;
167:               }
168:           /**
169:             End of File
170:           */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/tmr0.c  --
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16F18444
18:                    Driver Version    :  3.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr0.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            volatile uint16_t timer0ReloadVal16bit;
59:            
60:            /**
61:              Section: TMR0 APIs
62:            */
63:            
64:            
65:            void TMR0_Initialize(void)
66:            {
67:                // Set TMR0 to the options selected in the User Interface
68:            
69:                // T0CS FOSC/4; T0CKPS 1:1; T0ASYNC not_synchronised; 
70:                T0CON1 = 0x50;
0BB3  3050     MOVLW 0x50
0BB4  014B     MOVLB 0xB
0BB5  009F     MOVWF T0CON1
71:            
72:                // TMR0H 254; 
73:                TMR0H = 0xFE;
0BB6  30FE     MOVLW 0xFE
0BB7  009D     MOVWF TMR0H
74:            
75:                // TMR0L 12; 
76:                TMR0L = 0x0C;
0BB8  300C     MOVLW 0xC
0BB9  009C     MOVWF TMR0L
77:            
78:                // Load TMR0 value to the 16-bit reload variable
79:                timer0ReloadVal16bit = (TMR0H << 8) | TMR0L;
0BBA  081D     MOVF TMR0H, W
0BBB  0140     MOVLB 0x0
0BBC  00B1     MOVWF 0x31
0BBD  014B     MOVLB 0xB
0BBE  081C     MOVF TMR0L, W
0BBF  0140     MOVLB 0x0
0BC0  00B0     MOVWF timer0ReloadVal16bit
80:            
81:                // Clearing IF flag
82:                PIR0bits.TMR0IF = 0;
0BC1  014E     MOVLB 0xE
0BC2  128C     BCF PIR0, 0x5
83:            
84:                // T0OUTPS 1:1; T0EN enabled; T016BIT 16-bit; 
85:                T0CON0 = 0x90;
0BC3  3090     MOVLW 0x90
0BC4  014B     MOVLB 0xB
0BC5  009E     MOVWF T0CON0
86:            }
0BC6  0008     RETURN
87:            
88:            void TMR0_StartTimer(void)
89:            {
90:                // Start the Timer by writing to TMR0ON bit
91:                T0CON0bits.T0EN = 1;
0002  179E     BSF T0CON0, 0x7
92:            }
0003  0008     RETURN
93:            
94:            void TMR0_StopTimer(void)
95:            {
96:                // Stop the Timer by writing to TMR0ON bit
97:                T0CON0bits.T0EN = 0;
98:            }
99:            
100:           uint16_t TMR0_ReadTimer(void)
101:           {
102:               uint16_t readVal;
103:               uint8_t readValLow;
104:               uint8_t readValHigh;
105:           
106:               readValLow  = TMR0L;
0C88  014B     MOVLB 0xB
0C89  081C     MOVF TMR0L, W
0C8A  00F3     MOVWF 0x5F3
0C8B  0873     MOVF 0x5F3, W
0C8C  00FA     MOVWF 0x5FA
107:               readValHigh = TMR0H;
0C8D  081D     MOVF TMR0H, W
0C8E  00F3     MOVWF 0x5F3
0C8F  0873     MOVF 0x5F3, W
0C90  00FB     MOVWF 0x5FB
108:               readVal  = ((uint16_t)readValHigh << 8) + readValLow;
0C91  087A     MOVF 0x5FA, W
0C92  00F3     MOVWF 0x5F3
0C93  01F4     CLRF 0x5F4
0C94  087B     MOVF 0x5FB, W
0C95  00F5     MOVWF 0x5F5
0C96  01F6     CLRF 0x5F6
0C97  0875     MOVF 0x5F5, W
0C98  00F6     MOVWF 0x5F6
0C99  01F5     CLRF 0x5F5
0C9A  0873     MOVF 0x5F3, W
0C9B  0775     ADDWF 0x5F5, W
0C9C  00F8     MOVWF 0x5F8
0C9D  0874     MOVF 0x5F4, W
0C9E  3D76     ADDWFC 0x5F6, W
0C9F  00F9     MOVWF 0x5F9
109:           
110:               return readVal;
0CA0  0879     MOVF 0x5F9, W
0CA1  00F2     MOVWF 0x5F2
0CA2  0878     MOVF 0x5F8, W
0CA3  00F1     MOVWF 0x5F1
111:           }
0CA4  0008     RETURN
112:           
113:           void TMR0_WriteTimer(uint16_t timerVal)
114:           {
115:               // Write to the Timer0 register
116:               TMR0H = timerVal >> 8;
117:               TMR0L = (uint8_t) timerVal;
118:           }
119:           
120:           void TMR0_Reload(void)
121:           {
122:               // Write to the Timer0 register
123:               TMR0H = timer0ReloadVal16bit >> 8;
124:               TMR0L = (uint8_t) timer0ReloadVal16bit;
125:           }
126:           
127:           bool TMR0_HasOverflowOccured(void)
128:           {
129:               // check if  overflow has occurred by checking the TMRIF bit
130:               return(PIR0bits.TMR0IF);
131:           }
132:           /**
133:             End of File
134:           */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/pwm6.c  --
1:              /**
2:                PWM6 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm6.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM6.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                     Device            :  PIC16F18444
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 2.31 and above or later
21:                     MPLAB             :  MPLAB X 5.45
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm6.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM6_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM6POL active_hi; PWM6EN disabled; 
62:                PWM6CON = 0x00;   
0AC7  0147     MOVLB 0x7
0AC8  018E     CLRF PWM6CON
63:            
64:                // DC 64; 
65:                PWM6DCH = 0x40;   
0AC9  3040     MOVLW 0x40
0ACA  008D     MOVWF PWM6DCH
66:            
67:                // DC 3; 
68:                PWM6DCL = 0xC0;   
0ACB  30C0     MOVLW 0xC0
0ACC  008C     MOVWF PWM6DC
69:            
70:                // Select timer
71:                CCPTMRS1bits.P6TSEL = 1;
0ACD  0144     MOVLB 0x4
0ACE  081F     MOVF CCPTMRS1, W
0ACF  39F3     ANDLW 0xF3
0AD0  3804     IORLW 0x4
0AD1  009F     MOVWF CCPTMRS1
72:             }
0AD2  0008     RETURN
73:            
74:             void PWM6_LoadDutyValue(uint16_t dutyValue) //changes the duty cycle
75:             {
76:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
77:                 PWM6DCH = (dutyValue & 0x03FC)>>2;
0C0A  0850     MOVF 0x250, W
0C0B  00D2     MOVWF 0x252
0C0C  084F     MOVF 0x24F, W
0C0D  00D1     MOVWF 0x251
0C0E  36D2     LSRF 0x252, F
0C0F  0CD1     RRF 0x251, F
0C10  36D2     LSRF 0x252, F
0C11  0CD1     RRF 0x251, F
0C12  0851     MOVF 0x251, W
0C13  0147     MOVLB 0x7
0C14  008D     MOVWF PWM6DCH
78:                 
79:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
80:                 PWM6DCL = (dutyValue & 0x0003)<<6;
0C15  0140     MOVLB 0x0
0C16  084F     MOVF dutyValue, W
0C17  3903     ANDLW 0x3
0C18  00D1     MOVWF read
0C19  3005     MOVLW 0x5
0C1A  35D1     LSLF read, F
0C1B  3EFF     ADDLW 0xFF
0C1C  1D03     BTFSS STATUS, 0x2
0C1D  2C1A     GOTO 0x41A
0C1E  3551     LSLF read, W
0C1F  0147     MOVLB 0x7
0C20  008C     MOVWF PWM6DC
81:             }
0C21  0008     RETURN
82:             /**
83:              End of File
84:             */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/pin_manager.c
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16F18444
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            #include "../Subroutines.h"
51:            
52:            void (*IOCCF0_InterruptHandler)(void);
53:            void (*IOCCF1_InterruptHandler)(void);
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATA = 0x00;
0768  0140     MOVLB 0x0
0769  0198     CLRF LATA
61:                LATB = 0x00;
076A  0199     CLRF LATB
62:                LATC = 0x00;
076B  019A     CLRF LATC
63:            
64:                /**
65:                TRISx registers
66:                */
67:                TRISA = 0x0B;
076C  300B     MOVLW 0xB
076D  0092     MOVWF TRISA
68:                TRISB = 0x50;
076E  3050     MOVLW 0x50
076F  0093     MOVWF TRISB
69:                TRISC = 0x03;
0770  3003     MOVLW 0x3
0771  0094     MOVWF TRISC
70:            
71:                /**
72:                ANSELx registers
73:                */
74:                ANSELC = 0xFC;
0772  30FC     MOVLW 0xFC
0773  017E     MOVLB 0x3E
0774  00CE     MOVWF ANSELC
75:                ANSELB = 0xA0;
0775  30A0     MOVLW 0xA0
0776  00C3     MOVWF ANSELB
76:                ANSELA = 0x37;
0777  3037     MOVLW 0x37
0778  00B8     MOVWF ANSELA
77:            
78:                /**
79:                WPUx registers
80:                */
81:                WPUB = 0x00;
0779  01C4     CLRF WPUB
82:                WPUA = 0x00;
077A  01B9     CLRF WPUA
83:                WPUC = 0x00;
077B  01CF     CLRF WPUC
84:            
85:                /**
86:                ODx registers
87:                */
88:                ODCONA = 0x00;
077C  01BA     CLRF ODCONA
89:                ODCONB = 0x00;
077D  01C5     CLRF ODCONB
90:                ODCONC = 0x00;
077E  01D0     CLRF ODCONC
91:            
92:                /**
93:                SLRCONx registers
94:                */
95:                SLRCONA = 0x37;
077F  3037     MOVLW 0x37
0780  00BB     MOVWF SLRCONA
96:                SLRCONB = 0xF0;
0781  30F0     MOVLW 0xF0
0782  00C6     MOVWF SLRCONB
97:                SLRCONC = 0xFF;
0783  30FF     MOVLW 0xFF
0784  00D1     MOVWF SLRCONC
98:            
99:                /**
100:               INLVLx registers
101:               */
102:               INLVLA = 0x3F;
0785  303F     MOVLW 0x3F
0786  00BC     MOVWF INLVLA
103:               INLVLB = 0xF0;
0787  30F0     MOVLW 0xF0
0788  00C7     MOVWF INLVLB
104:               INLVLC = 0xFF;
0789  30FF     MOVLW 0xFF
078A  00D2     MOVWF INLVLC
105:           
106:               /**
107:               IOCx registers 
108:               */
109:               //interrupt on change for group IOCCF - flag
110:               IOCCFbits.IOCCF0 = 0;
078B  1055     BCF IOCCF, 0x0
111:               //interrupt on change for group IOCCF - flag
112:               IOCCFbits.IOCCF1 = 0;
078C  10D5     BCF IOCCF, 0x1
113:               //interrupt on change for group IOCCN - negative
114:               IOCCNbits.IOCCN0 = 0;
078D  1054     BCF IOCCN, 0x0
115:               //interrupt on change for group IOCCN - negative
116:               IOCCNbits.IOCCN1 = 0;
078E  10D4     BCF IOCCN, 0x1
117:               //interrupt on change for group IOCCP - positive
118:               IOCCPbits.IOCCP0 = 1;
078F  1453     BSF IOCCP, 0x0
119:               //interrupt on change for group IOCCP - positive
120:               IOCCPbits.IOCCP1 = 1;
0790  14D3     BSF IOCCP, 0x1
121:           
122:               // register default IOC callback functions at runtime; use these methods to register a custom function
123:               //IOCCF0_SetInterruptHandler(IOCCF0_DefaultInterruptHandler); setting this to a custom function does not work here
124:               //IOCCF1_SetInterruptHandler(IOCCF1_DefaultInterruptHandler);
125:              
126:               // Enable IOCI interrupt 
127:               PIE0bits.IOCIE = 1; 
0791  014E     MOVLB 0xE
0792  1616     BSF PIE0, 0x4
128:           	
129:               SSP1CLKPPS = 0x0E;   //RB6->MSSP1:SCL1;    
0793  300E     MOVLW 0xE
0794  017D     MOVLB 0x3D
0795  00C5     MOVWF SSP1CLKPPS
130:               RB6PPS = 0x13;   //RB6->MSSP1:SCL1;    
0796  3013     MOVLW 0x13
0797  017E     MOVLB 0x3E
0798  009E     MOVWF RB6PPS
131:               RC4PPS = 0x0D;   //RC4->PWM6:PWM6OUT;    
0799  300D     MOVLW 0xD
079A  00A4     MOVWF RC4PPS
132:               RB4PPS = 0x14;   //RB4->MSSP1:SDA1;    
079B  3014     MOVLW 0x14
079C  009C     MOVWF RB4PPS
133:               SSP1DATPPS = 0x0C;   //RB4->MSSP1:SDA1;    
079D  300C     MOVLW 0xC
079E  017D     MOVLB 0x3D
079F  00C6     MOVWF SSP1DATPPS
134:           
135:               //Make sure pins are set like we want them
136:               RA2_UNUSED_SetLow(); //these are unused pins, recommended state for such pins is to be set low
07A0  0140     MOVLB 0x0
07A1  1118     BCF LATA, 0x2
137:               RA4_UNUSED_SetLow();
07A2  1218     BCF LATA, 0x4
138:               RA5_UNUSED_SetLow();
07A3  1298     BCF LATA, 0x5
139:               RB5_UNUSED_SetLow();
07A4  1299     BCF LATB, 0x5
140:               RB7_UNUSED_SetLow();
07A5  1399     BCF LATB, 0x7
141:               SW1_SetLow(); //switch pins are high when pressed
07A6  101A     BCF LATC, 0x0
142:               SW2_SetLow();
07A7  109A     BCF LATC, 0x1
143:               BL_SetLow(); //this blanks the tubes
07A8  121A     BCF LATC, 0x4
144:               LE_SetLow(); //data transfer is off
07A9  131A     BCF LATC, 0x6
145:               CLK_SetLow(); //clock line off/low
07AA  119A     BCF LATC, 0x3
146:               HVPS_ENABLE_SetLow(); //HVPS off
07AB  139A     BCF LATC, 0x7
147:           }
07AC  0008     RETURN
148:             
149:           void PIN_MANAGER_IOC(void)
150:           {   
151:           	// interrupt on change for pin IOCCF0
152:               if(IOCCFbits.IOCCF0 == 1)
0B47  017E     MOVLB 0x3E
0B48  1C55     BTFSS IOCCF, 0x0
0B49  2B50     GOTO 0x350
153:               {
154:                   //IOCCF0_ISR();
155:                   di();
0B4A  138B     BCF INTCON, 0x7
156:                   SW1Interrupt();
0B4B  318A     MOVLP 0xA
0B4C  2297     CALL 0x297
0B4D  318B     MOVLP 0xB
157:                   IOCCFbits.IOCCF0 = 0;
0B4E  017E     MOVLB 0x3E
0B4F  1055     BCF IOCCF, 0x0
158:               }	
159:           	// interrupt on change for pin IOCCF1
160:               if(IOCCFbits.IOCCF1 == 1)
0B50  1CD5     BTFSS IOCCF, 0x1
0B51  0008     RETURN
161:               {
162:                   //IOCCF1_ISR();
163:                   di();
0B52  138B     BCF INTCON, 0x7
164:                   SW2Interrupt();
0B53  318A     MOVLP 0xA
0B54  22A3     CALL 0x2A3
165:                   IOCCFbits.IOCCF1 = 0;
0B55  017E     MOVLB 0x3E
0B56  10D5     BCF IOCCF, 0x1
166:               }	
167:           }
0B57  0008     RETURN
168:           
169:           //fuck all this extra junk, we doin it live in the IOC function
170:           ///**
171:           //   IOCCF0 Interrupt Service Routine
172:           //*/
173:           //void IOCCF0_ISR(void) {
174:           //
175:           //    // Add custom IOCCF0 code
176:           //
177:           //    // Call the interrupt handler for the callback registered at runtime
178:           //    if(IOCCF0_InterruptHandler)
179:           //    {
180:           //        IOCCF0_InterruptHandler();
181:           //    }
182:           //    IOCCFbits.IOCCF0 = 0;
183:           //}
184:           //
185:           ///**
186:           //  Allows selecting an interrupt handler for IOCCF0 at application runtime
187:           //*/
188:           //void IOCCF0_SetInterruptHandler(void (* InterruptHandler)(void)){
189:           //    IOCCF0_InterruptHandler = InterruptHandler;
190:           //}
191:           //
192:           ///**
193:           //  Default interrupt handler for IOCCF0
194:           //*/
195:           //void IOCCF0_DefaultInterruptHandler(void){
196:           //    // add your IOCCF0 interrupt custom code
197:           //    // or set custom function using IOCCF0_SetInterruptHandler()
198:           //}
199:           //
200:           ///**
201:           //   IOCCF1 Interrupt Service Routine
202:           //*/
203:           //void IOCCF1_ISR(void) {
204:           //
205:           //    // Add custom IOCCF1 code
206:           //
207:           //    // Call the interrupt handler for the callback registered at runtime
208:           //    if(IOCCF1_InterruptHandler)
209:           //    {
210:           //        IOCCF1_InterruptHandler();
211:           //    }
212:           //    IOCCFbits.IOCCF1 = 0;
213:           //}
214:           //
215:           ///**
216:           //  Allows selecting an interrupt handler for IOCCF1 at application runtime
217:           //*/
218:           //void IOCCF1_SetInterruptHandler(void (* InterruptHandler)(void)){
219:           //    IOCCF1_InterruptHandler = InterruptHandler;
220:           //}
221:           //
222:           ///**
223:           //  Default interrupt handler for IOCCF1
224:           //*/
225:           //void IOCCF1_DefaultInterruptHandler(void){
226:           //    // add your IOCCF1 interrupt custom code
227:           //    // or set custom function using IOCCF1_SetInterruptHandler()
228:           //}
229:           
230:           /**
231:            End of File
232:           */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/mcc.c  ---
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16F18444
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                PMD_Initialize();
0C22  318A     MOVLP 0xA
0C23  2277     CALL 0x277
0C24  318C     MOVLP 0xC
53:                I2C1_Initialize();
0C25  318A     MOVLP 0xA
0C26  2251     CALL 0x251
0C27  318C     MOVLP 0xC
54:                PIN_MANAGER_Initialize();
0C28  3187     MOVLP 0x7
0C29  2768     CALL 0x768
0C2A  318C     MOVLP 0xC
55:                OSCILLATOR_Initialize();
0C2B  318A     MOVLP 0xA
0C2C  225A     CALL 0x25A
0C2D  318C     MOVLP 0xC
56:                PWM6_Initialize();
0C2E  318A     MOVLP 0xA
0C2F  22C7     CALL 0x2C7
0C30  318C     MOVLP 0xC
57:                TMR4_Initialize();
0C31  318B     MOVLP 0xB
0C32  23DD     CALL 0x3DD
0C33  318C     MOVLP 0xC
58:                TMR2_Initialize();
0C34  318A     MOVLP 0xA
0C35  22F9     CALL 0x2F9
0C36  318C     MOVLP 0xC
59:                TMR0_Initialize();
0C37  318B     MOVLP 0xB
0C38  23B3     CALL 0x3B3
60:            }
0C39  0008     RETURN
61:            
62:            void OSCILLATOR_Initialize(void)
63:            {
64:                // NOSC HFINTOSC; NDIV 1; 
65:                OSCCON1 = 0x60;
0A5A  3060     MOVLW 0x60
0A5B  0151     MOVLB 0x11
0A5C  008D     MOVWF OSCCON1
66:                // CSWHOLD may proceed; SOSCPWR Low power; 
67:                OSCCON3 = 0x00;
0A5D  018F     CLRF OSCCON3
68:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
69:                OSCEN = 0x00;
0A5E  0191     CLRF OSCEN
70:                // HFFRQ 4_MHz; 
71:                OSCFRQ = 0x02;
0A5F  3002     MOVLW 0x2
0A60  0093     MOVWF OSCFRQ
72:                // HFTUN 0; 
73:                OSCTUNE = 0x00;
0A61  0192     CLRF OSCTUNE
74:            }
0A62  0008     RETURN
75:            
76:            void PMD_Initialize(void)
77:            {
78:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; FVRMD FVR enabled; IOCMD IOC enabled; NVMMD NVM enabled; 
79:                PMD0 = 0x00;
0A77  014F     MOVLB 0xF
0A78  0196     CLRF PMD0
80:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
81:                PMD1 = 0x00;
0A79  0197     CLRF PMD1
82:                // NCO1MD NCO1 enabled; 
83:                PMD2 = 0x00;
0A7A  0198     CLRF PMD2
84:                // ZCDMD ZCD enabled; CMP1MD CMP1 enabled; ADCMD ADC enabled; CMP2MD CMP2 enabled; DAC1MD DAC1 enabled; 
85:                PMD3 = 0x00;
0A7B  0199     CLRF PMD3
86:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; CCP4MD CCP4 enabled; CCP3MD CCP3 enabled; PWM6MD PWM6 enabled; PWM7MD PWM7 enabled; 
87:                PMD4 = 0x00;
0A7C  019A     CLRF PMD4
88:                // CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; 
89:                PMD5 = 0x00;
0A7D  019B     CLRF PMD5
90:                // U1MD EUSART1 enabled; MSSP1MD MSSP1 enabled; 
91:                PMD6 = 0x00;
0A7E  019C     CLRF PMD6
92:                // CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; DSM1MD DSM enabled; SMT1MD SMT1 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
93:                PMD7 = 0x00;
0A7F  019D     CLRF PMD7
94:            }
0A80  0008     RETURN
95:            
96:            
97:            /**
98:             End of File
99:            */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/interrupt_manager.c
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
19:                    Device            :  PIC16F18444
20:                    Driver Version    :  2.04
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.31 and above or later
23:                    MPLAB 	          :  MPLAB X 5.45
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void __interrupt() INTERRUPT_InterruptManager (void)
0004  147E     BSF 0x7FE, 0x0
0005  3180     MOVLP 0x0
53:            {
54:                // interrupt handler
55:                if(PIE0bits.IOCIE == 1 && PIR0bits.IOCIF == 1)
0006  014E     MOVLB 0xE
0007  1A16     BTFSC PIE0, 0x4
0008  1E0C     BTFSS PIR0, 0x4
0009  280E     GOTO 0xE
56:                {
57:                    PIN_MANAGER_IOC();
000A  318B     MOVLP 0xB
000B  2347     CALL 0x347
000C  3180     MOVLP 0x0
58:                }
000D  2815     GOTO 0x15
59:                else if(INTCONbits.PEIE == 1)
000E  1B0B     BTFSC INTCON, 0x6
60:                {
61:                    if(PIE4bits.TMR4IE == 1 && PIR4bits.TMR4IF == 1)
000F  1D9A     BTFSS PIE4, 0x3
0010  2815     GOTO 0x15
0011  1D90     BTFSS PIR4, 0x3
0012  2815     GOTO 0x15
62:                    {
63:                        TMR4_ISR();
0013  3189     MOVLP 0x9
0014  21D1     CALL 0x1D1
64:                    } 
65:                    else
66:                    {
67:                        //Unhandled Interrupt
68:                    }
69:                }      
70:                else
71:                {
72:                    //Unhandled Interrupt
73:                }
74:            }
0015  107E     BCF 0x77E, 0x0
75:            /**
76:             End of File
77:            */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/i2c1_master.c
1:             /**
2:               I2C1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 i2c1_master.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the I2C1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for I2C1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16F18444
18:                    Driver Version    :  1.0.2
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "i2c1_master.h"
48:            #include <xc.h>
49:            
50:            // I2C1 STATES
51:            typedef enum {
52:                I2C1_IDLE = 0,
53:                I2C1_SEND_ADR_READ,
54:                I2C1_SEND_ADR_WRITE,
55:                I2C1_TX,
56:                I2C1_RX,
57:                I2C1_RCEN,
58:                I2C1_TX_EMPTY,      
59:                I2C1_SEND_RESTART_READ,
60:                I2C1_SEND_RESTART_WRITE,
61:                I2C1_SEND_RESTART,
62:                I2C1_SEND_STOP,
63:                I2C1_RX_ACK,
64:                I2C1_RX_NACK_STOP,
65:                I2C1_RX_NACK_RESTART,
66:                I2C1_RESET,
67:                I2C1_ADDRESS_NACK,
68:            
69:            } i2c1_fsm_states_t;
70:            
71:            // I2C1 Event callBack List
72:            typedef enum {
73:                I2C1_DATA_COMPLETE = 0,
74:                I2C1_WRITE_COLLISION,
75:                I2C1_ADDR_NACK,
76:                I2C1_DATA_NACK,
77:                I2C1_TIMEOUT,
78:                I2C1_NULL
79:            } i2c1_callbackIndex_t;
80:            
81:            // I2C1 Status Structure
82:            typedef struct
83:            {
84:                i2c1_callback_t callbackTable[6];
85:                void *callbackPayload[6];           //  each callBack can have a payload
86:                uint16_t time_out;                  // I2C1 Timeout Counter between I2C1 Events.
87:                uint16_t time_out_value;            // Reload value for the timeouts
88:                i2c1_address_t address;             // The I2C1 Address
89:                uint8_t *data_ptr;                  // pointer to a data buffer
90:                size_t data_length;                 // Bytes in the data buffer
91:                i2c1_fsm_states_t state;            // Driver State
92:                i2c1_error_t error;
93:                unsigned addressNackCheck:1;
94:                unsigned busy:1;
95:                unsigned inUse:1;
96:                unsigned bufferFree:1;
97:            
98:            } i2c1_status_t;
99:            
100:           static void I2C1_SetCallback(i2c1_callbackIndex_t idx, i2c1_callback_t cb, void *ptr);
101:           static void I2C1_Poller(void);
102:           static inline void I2C1_MasterFsm(void);
103:           
104:           /* I2C1 interfaces */
105:           static inline bool I2C1_MasterOpen(void);
106:           static inline void I2C1_MasterClose(void);    
107:           static inline uint8_t I2C1_MasterGetRxData(void);
108:           static inline void I2C1_MasterSendTxData(uint8_t data);
109:           static inline void I2C1_MasterEnableRestart(void);
110:           static inline void I2C1_MasterDisableRestart(void);
111:           static inline void I2C1_MasterStartRx(void);
112:           static inline void I2C1_MasterStart(void);
113:           static inline void I2C1_MasterStop(void);
114:           static inline bool I2C1_MasterIsNack(void);
115:           static inline void I2C1_MasterSendAck(void);
116:           static inline void I2C1_MasterSendNack(void);
117:           static inline void I2C1_MasterClearBusCollision(void);
118:           
119:           /* Interrupt interfaces */
120:           static inline void I2C1_MasterEnableIrq(void);
121:           static inline bool I2C1_MasterIsIrqEnabled(void);
122:           static inline void I2C1_MasterDisableIrq(void);
123:           static inline void I2C1_MasterClearIrq(void);
124:           static inline void I2C1_MasterSetIrq(void);
125:           static inline void I2C1_MasterWaitForEvent(void);
126:           
127:           static i2c1_fsm_states_t I2C1_DO_IDLE(void);
128:           static i2c1_fsm_states_t I2C1_DO_SEND_ADR_READ(void);
129:           static i2c1_fsm_states_t I2C1_DO_SEND_ADR_WRITE(void);
130:           static i2c1_fsm_states_t I2C1_DO_TX(void);
131:           static i2c1_fsm_states_t I2C1_DO_RX(void);
132:           static i2c1_fsm_states_t I2C1_DO_RCEN(void);
133:           static i2c1_fsm_states_t I2C1_DO_TX_EMPTY(void);
134:           static i2c1_fsm_states_t I2C1_DO_SEND_RESTART_READ(void);
135:           static i2c1_fsm_states_t I2C1_DO_SEND_RESTART_WRITE(void);
136:           static i2c1_fsm_states_t I2C1_DO_SEND_RESTART(void);
137:           static i2c1_fsm_states_t I2C1_DO_SEND_STOP(void);
138:           static i2c1_fsm_states_t I2C1_DO_RX_ACK(void);
139:           static i2c1_fsm_states_t I2C1_DO_RX_NACK_STOP(void);
140:           static i2c1_fsm_states_t I2C1_DO_RX_NACK_RESTART(void);
141:           static i2c1_fsm_states_t I2C1_DO_RESET(void);
142:           static i2c1_fsm_states_t I2C1_DO_ADDRESS_NACK(void);
143:           
144:           
145:           typedef i2c1_fsm_states_t (*i2c1FsmHandler)(void);
146:           const i2c1FsmHandler i2c1_fsmStateTable[] = {
147:               I2C1_DO_IDLE,
148:               I2C1_DO_SEND_ADR_READ,
149:               I2C1_DO_SEND_ADR_WRITE,
150:               I2C1_DO_TX,
151:               I2C1_DO_RX,
152:               I2C1_DO_RCEN,
153:               I2C1_DO_TX_EMPTY,
154:               I2C1_DO_SEND_RESTART_READ,
155:               I2C1_DO_SEND_RESTART_WRITE,
156:               I2C1_DO_SEND_RESTART,
157:               I2C1_DO_SEND_STOP,
158:               I2C1_DO_RX_ACK,
159:               I2C1_DO_RX_NACK_STOP,
160:               I2C1_DO_RX_NACK_RESTART,
161:               I2C1_DO_RESET,
162:               I2C1_DO_ADDRESS_NACK,
163:           };
164:           
165:           i2c1_status_t I2C1_Status = {0};
166:           
167:           void I2C1_Initialize()
168:           {
169:               SSP1STAT = 0x00;
0A51  0143     MOVLB 0x3
0A52  018F     CLRF SSP1STAT
170:               SSP1CON1 = 0x08;
0A53  3008     MOVLW 0x8
0A54  0090     MOVWF SSP1CON1
171:               SSP1CON2 = 0x00;
0A55  0191     CLRF SSP1CON2
172:               SSP1ADD  = 0x09;
0A56  3009     MOVLW 0x9
0A57  008D     MOVWF SSP1ADD
173:               SSP1CON1bits.SSPEN = 0;
0A58  1290     BCF SSP1CON1, 0x5
174:           }
0A59  0008     RETURN
175:           
176:           i2c1_error_t I2C1_Open(i2c1_address_t address)
0F0B  00F2     MOVWF 0x1F2
177:           {
178:               i2c1_error_t returnValue = I2C1_BUSY;
0F0C  01F3     CLRF 0x1F3
0F0D  0AF3     INCF 0x1F3, F
179:               
180:               if(!I2C1_Status.inUse)
0F0E  0141     MOVLB 0x1
0F0F  193C     BTFSC 0xBC, 0x2
0F10  2F40     GOTO 0x740
181:               {
182:                   I2C1_Status.address = address;
0F11  0872     MOVF 0xF2, W
0F12  00F1     MOVWF 0xF1
0F13  0871     MOVF 0xF1, W
0F14  00B6     MOVWF 0xB6
183:                   I2C1_Status.busy = 0;
0F15  10BC     BCF 0xBC, 0x1
184:                   I2C1_Status.inUse = 1;
0F16  153C     BSF 0xBC, 0x2
185:                   I2C1_Status.addressNackCheck = 0;
0F17  103C     BCF 0xBC, 0x0
186:                   I2C1_Status.state = I2C1_RESET;
0F18  300E     MOVLW 0xE
0F19  00F1     MOVWF 0xF1
0F1A  0871     MOVF 0xF1, W
0F1B  00BA     MOVWF 0xBA
187:                   I2C1_Status.time_out_value = 500; // MCC should determine a reasonable starting value here.
0F1C  30F4     MOVLW 0xF4
0F1D  00B4     MOVWF 0xB4
0F1E  3001     MOVLW 0x1
0F1F  00B5     MOVWF 0xB5
188:                   I2C1_Status.bufferFree = 1;
0F20  15BC     BSF 0xBC, 0x3
189:           
190:                   // set all the call backs to a default of sending stop
191:                   I2C1_Status.callbackTable[I2C1_DATA_COMPLETE]=I2C1_CallbackReturnStop;
0F21  30AF     MOVLW 0xAF
0F22  00A0     MOVWF I2C1_Status
0F23  3009     MOVLW 0x9
0F24  00A1     MOVWF 0xA1
192:                   I2C1_Status.callbackPayload[I2C1_DATA_COMPLETE] = NULL;
0F25  01AC     CLRF 0xAC
193:                   I2C1_Status.callbackTable[I2C1_WRITE_COLLISION]=I2C1_CallbackReturnStop;
0F26  30AF     MOVLW 0xAF
0F27  00A2     MOVWF 0xA2
0F28  3009     MOVLW 0x9
0F29  00A3     MOVWF 0xA3
194:                   I2C1_Status.callbackPayload[I2C1_WRITE_COLLISION] = NULL;
0F2A  01AD     CLRF 0xAD
195:                   I2C1_Status.callbackTable[I2C1_ADDR_NACK]=I2C1_CallbackReturnStop;
0F2B  30AF     MOVLW 0xAF
0F2C  00A4     MOVWF 0xA4
0F2D  3009     MOVLW 0x9
0F2E  00A5     MOVWF 0xA5
196:                   I2C1_Status.callbackPayload[I2C1_ADDR_NACK] = NULL;
0F2F  01AE     CLRF 0xAE
197:                   I2C1_Status.callbackTable[I2C1_DATA_NACK]=I2C1_CallbackReturnStop;
0F30  30AF     MOVLW 0xAF
0F31  00A6     MOVWF 0xA6
0F32  3009     MOVLW 0x9
0F33  00A7     MOVWF 0xA7
198:                   I2C1_Status.callbackPayload[I2C1_DATA_NACK] = NULL;
0F34  01AF     CLRF 0xAF
199:                   I2C1_Status.callbackTable[I2C1_TIMEOUT]=I2C1_CallbackReturnReset;
0F35  30B1     MOVLW 0xB1
0F36  00A8     MOVWF 0xA8
0F37  3009     MOVLW 0x9
0F38  00A9     MOVWF 0xA9
200:                   I2C1_Status.callbackPayload[I2C1_TIMEOUT] = NULL;
0F39  01B0     CLRF 0xB0
201:                   
202:                   I2C1_MasterClearIrq();
0F3A  3189     MOVLP 0x9
0F3B  21B9     CALL 0x1B9
0F3C  318F     MOVLP 0xF
203:                   I2C1_MasterOpen();
0F3D  318A     MOVLP 0xA
0F3E  228C     CALL 0x28C
204:                   returnValue = I2C1_NOERR;
0F3F  01F3     CLRF 0xF3
205:               }
206:               return returnValue;
0F40  0873     MOVF 0xF3, W
207:           }
0F41  0008     RETURN
208:           
209:           i2c1_error_t I2C1_Close(void)
210:           {
211:               i2c1_error_t returnValue = I2C1_BUSY;
0C3A  01F2     CLRF 0xF2
0C3B  0AF2     INCF 0xF2, F
212:               if(!I2C1_Status.busy)
0C3C  0141     MOVLB 0x1
0C3D  18BC     BTFSC 0xBC, 0x1
0C3E  2C51     GOTO 0x451
213:               {
214:                   I2C1_Status.inUse = 0;
0C3F  113C     BCF 0xBC, 0x2
215:                   I2C1_Status.address = 0xff;
0C40  30FF     MOVLW 0xFF
0C41  00F1     MOVWF 0xF1
0C42  0871     MOVF 0xF1, W
0C43  00B6     MOVWF 0xB6
216:                   I2C1_MasterClearIrq();
0C44  3189     MOVLP 0x9
0C45  21B9     CALL 0x1B9
0C46  318C     MOVLP 0xC
217:                   I2C1_MasterDisableIrq();
0C47  3189     MOVLP 0x9
0C48  21AD     CALL 0x1AD
0C49  318C     MOVLP 0xC
218:                   I2C1_MasterClose();
0C4A  3189     MOVLP 0x9
0C4B  21BC     CALL 0x1BC
219:                   returnValue = I2C1_Status.error;
0C4C  0141     MOVLB 0x1
0C4D  083B     MOVF 0xBB, W
0C4E  00F1     MOVWF 0xF1
0C4F  0871     MOVF 0xF1, W
0C50  00F2     MOVWF 0xF2
220:               }
221:               return returnValue;
0C51  0872     MOVF 0xF2, W
222:           }
0C52  0008     RETURN
223:           
224:           i2c1_error_t I2C1_MasterOperation(bool read)
0CE0  0140     MOVLB 0x0
0CE1  00D1     MOVWF read
225:           {
226:               i2c1_error_t returnValue = I2C1_BUSY;
0CE2  01D2     CLRF returnValue
0CE3  0AD2     INCF returnValue, F
227:               if(!I2C1_Status.busy)
0CE4  0141     MOVLB 0x1
0CE5  18BC     BTFSC 0xBC, 0x1
0CE6  2CFB     GOTO 0x4FB
228:               {
229:                   I2C1_Status.busy = true;
0CE7  14BC     BSF 0xBC, 0x1
230:                   returnValue = I2C1_NOERR;
0CE8  0140     MOVLB 0x0
0CE9  01D2     CLRF returnValue
231:           
232:                   if(read)
0CEA  0851     MOVF read, W
0CEB  1903     BTFSC STATUS, 0x2
0CEC  2CF1     GOTO 0x4F1
233:                   {
234:                       I2C1_Status.state = I2C1_SEND_ADR_READ;
0CED  0141     MOVLB 0x1
0CEE  01BA     CLRF 0xBA
0CEF  0ABA     INCF 0xBA, F
235:                   }
0CF0  2CF6     GOTO 0x4F6
236:                   else
237:                   {
238:                       I2C1_Status.state = I2C1_SEND_ADR_WRITE;
0CF1  3002     MOVLW 0x2
0CF2  00FB     MOVWF 0xFB
0CF3  087B     MOVF 0xFB, W
0CF4  0141     MOVLB 0x1
0CF5  00BA     MOVWF 0xBA
239:                   }
240:                   I2C1_MasterStart();
0CF6  3189     MOVLP 0x9
0CF7  21BF     CALL 0x1BF
0CF8  318C     MOVLP 0xC
241:                   I2C1_Poller();
0CF9  318A     MOVLP 0xA
0CFA  226D     CALL 0x26D
242:               }
243:               return returnValue;
0CFB  0140     MOVLB 0x0
0CFC  0852     MOVF returnValue, W
244:           }
0CFD  0008     RETURN
245:           
246:           i2c1_error_t I2C1_MasterRead(void)
247:           {
248:               return I2C1_MasterOperation(true);
249:           }
250:           
251:           i2c1_error_t I2C1_MasterWrite(void)
252:           {
253:               return I2C1_MasterOperation(false);
09FD  3000     MOVLW 0x0
09FE  318C     MOVLP 0xC
09FF  24E0     CALL 0x4E0
254:           }
0A00  0008     RETURN
255:           
256:           void I2C1_SetTimeOut(uint8_t timeOutValue)
257:           {
258:               I2C1_MasterDisableIrq();
259:               I2C1_Status.time_out_value = timeOutValue;
260:               I2C1_MasterEnableIrq();
261:           }
262:           
263:           void I2C1_SetBuffer(void *buffer, size_t bufferSize)
0AEB  00F4     MOVWF buffer
264:           {
265:               if(I2C1_Status.bufferFree)
0AEC  0141     MOVLB 0x1
0AED  1DBC     BTFSS 0xBC, 0x3
0AEE  0008     RETURN
266:               {
267:                   I2C1_Status.data_ptr = buffer;
0AEF  0874     MOVF 0xF4, W
0AF0  00F3     MOVWF 0xF3
0AF1  0873     MOVF 0xF3, W
0AF2  00B7     MOVWF 0xB7
268:                   I2C1_Status.data_length = bufferSize;
0AF3  0872     MOVF 0xF2, W
0AF4  00B9     MOVWF 0xB9
0AF5  0871     MOVF 0xF1, W
0AF6  00B8     MOVWF 0xB8
269:                   I2C1_Status.bufferFree = false;
0AF7  11BC     BCF 0xBC, 0x3
270:               }
271:           }
0AF8  0008     RETURN
272:           
273:           void I2C1_SetDataCompleteCallback(i2c1_callback_t cb, void *ptr)
274:           {
275:               I2C1_SetCallback(I2C1_DATA_COMPLETE, cb, ptr);
0AAF  0877     MOVF 0xF7, W
0AB0  00F2     MOVWF 0xF2
0AB1  0876     MOVF 0xF6, W
0AB2  00F1     MOVWF 0xF1
0AB3  0878     MOVF 0xF8, W
0AB4  00F9     MOVWF 0xF9
0AB5  0879     MOVF 0xF9, W
0AB6  00F3     MOVWF 0xF3
0AB7  3000     MOVLW 0x0
0AB8  318D     MOVLP 0xD
0AB9  2543     CALL 0x543
276:           }
0ABA  0008     RETURN
277:           
278:           void I2C1_SetWriteCollisionCallback(i2c1_callback_t cb, void *ptr)
279:           {
280:               I2C1_SetCallback(I2C1_WRITE_COLLISION, cb, ptr);
281:           }
282:           
283:           void I2C1_SetAddressNackCallback(i2c1_callback_t cb, void *ptr)
284:           {
285:               I2C1_SetCallback(I2C1_ADDR_NACK, cb, ptr);
0ABB  0877     MOVF 0xF7, W
0ABC  00F2     MOVWF 0xF2
0ABD  0876     MOVF 0xF6, W
0ABE  00F1     MOVWF 0xF1
0ABF  0878     MOVF 0xF8, W
0AC0  00F9     MOVWF 0xF9
0AC1  0879     MOVF 0xF9, W
0AC2  00F3     MOVWF 0xF3
0AC3  3002     MOVLW 0x2
0AC4  318D     MOVLP 0xD
0AC5  2543     CALL 0x543
286:           }
0AC6  0008     RETURN
287:           
288:           void I2C1_SetDataNackCallback(i2c1_callback_t cb, void *ptr)
289:           {
290:               I2C1_SetCallback(I2C1_DATA_NACK, cb, ptr);
291:           }
292:           
293:           void I2C1_SetTimeoutCallback(i2c1_callback_t cb, void *ptr)
294:           {
295:               I2C1_SetCallback(I2C1_TIMEOUT, cb, ptr);
296:           }
297:           
298:           static void I2C1_SetCallback(i2c1_callbackIndex_t idx, i2c1_callback_t cb, void *ptr)
0D43  00F5     MOVWF 0xF5
299:           {
300:               if(cb)
0D44  0871     MOVF 0xF1, W
0D45  0472     IORWF 0xF2, W
0D46  1903     BTFSC STATUS, 0x2
0D47  2D59     GOTO 0x559
301:               {
302:                   I2C1_Status.callbackTable[idx] = cb;
0D48  3575     LSLF 0xF5, W
0D49  3EA0     ADDLW 0xA0
0D4A  0086     MOVWF FSR1L
0D4B  0187     CLRF FSR1H
0D4C  0871     MOVF 0xF1, W
0D4D  3FC0     MOVWI [0]FSR1
0D4E  0872     MOVF 0xF2, W
0D4F  3FC1     MOVWI [1]FSR1
303:                   I2C1_Status.callbackPayload[idx] = ptr;
0D50  0873     MOVF 0xF3, W
0D51  00F4     MOVWF 0xF4
0D52  0875     MOVF 0xF5, W
0D53  3EAC     ADDLW 0xAC
0D54  0086     MOVWF FSR1L
0D55  0187     CLRF FSR1H
0D56  0874     MOVF 0xF4, W
0D57  0081     MOVWF INDF1
304:               }
0D58  0008     RETURN
305:               else
306:               {
307:                   I2C1_Status.callbackTable[idx] = I2C1_CallbackReturnStop;
0D59  3575     LSLF 0xF5, W
0D5A  3EA0     ADDLW 0xA0
0D5B  0086     MOVWF FSR1L
0D5C  0187     CLRF FSR1H
0D5D  30AF     MOVLW 0xAF
0D5E  3FC0     MOVWI [0]FSR1
0D5F  3009     MOVLW 0x9
0D60  3FC1     MOVWI [1]FSR1
308:                   I2C1_Status.callbackPayload[idx] = NULL;
0D61  0875     MOVF 0xF5, W
0D62  3EAC     ADDLW 0xAC
0D63  0086     MOVWF FSR1L
0D64  0187     CLRF FSR1H
0D65  0181     CLRF INDF1
309:               }
310:           }
0D66  0008     RETURN
311:           
312:           static void I2C1_Poller(void)
313:           {
314:               while(I2C1_Status.busy)
0A6D  0141     MOVLB 0x1
0A6E  1CBC     BTFSS 0xBC, 0x1
0A6F  0008     RETURN
0A76  2A6D     GOTO 0x26D
315:               {
316:                   I2C1_MasterWaitForEvent();
0A70  3189     MOVLP 0x9
0A71  21F9     CALL 0x1F9
0A72  318A     MOVLP 0xA
317:                   I2C1_MasterFsm();
0A73  318D     MOVLP 0xD
0A74  258B     CALL 0x58B
0A75  318A     MOVLP 0xA
318:               }
319:           }
320:           
321:           static inline void I2C1_MasterFsm(void)
322:           {
323:               I2C1_MasterClearIrq();
0D8B  3189     MOVLP 0x9
0D8C  21B9     CALL 0x1B9
0D8D  318D     MOVLP 0xD
324:           
325:               if(I2C1_Status.addressNackCheck && I2C1_MasterIsNack())
0D8E  0141     MOVLB 0x1
0D8F  1C3C     BTFSS 0xBC, 0x0
0D90  2D9D     GOTO 0x59D
0D91  318A     MOVLP 0xA
0D92  2215     CALL 0x215
0D93  318D     MOVLP 0xD
0D94  3A00     XORLW 0x0
0D95  1903     BTFSC STATUS, 0x2
0D96  2D9D     GOTO 0x59D
326:               {
327:                   I2C1_Status.state = I2C1_ADDRESS_NACK;
0D97  300F     MOVLW 0xF
0D98  0140     MOVLB 0x0
0D99  00CE     MOVWF 0x4E
0D9A  084E     MOVF 0x4E, W
0D9B  0141     MOVLB 0x1
0D9C  00BA     MOVWF 0xBA
328:               }
329:               I2C1_Status.state = i2c1_fsmStateTable[I2C1_Status.state]();
0D9D  0141     MOVLB 0x1
0D9E  083A     MOVF 0xBA, W
0D9F  0140     MOVLB 0x0
0DA0  00CE     MOVWF 0x4E
0DA1  01CF     CLRF dutyValue
0DA2  35CE     LSLF 0x4E, F
0DA3  0DCF     RLF dutyValue, F
0DA4  30F2     MOVLW 0xF2
0DA5  074E     ADDWF 0x4E, W
0DA6  0084     MOVWF FSR0
0DA7  3087     MOVLW 0x87
0DA8  3D4F     ADDWFC dutyValue, W
0DA9  0085     MOVWF FSR0H
0DAA  3F01     MOVIW [1]FSR0
0DAB  008A     MOVWF PCLATH
0DAC  3F00     MOVIW [0]FSR0
0DAD  000A     CALLW
0DAE  318D     MOVLP 0xD
0DAF  0140     MOVLB 0x0
0DB0  00D0     MOVWF 0x50
0DB1  0850     MOVF 0x50, W
0DB2  0141     MOVLB 0x1
0DB3  00BA     MOVWF 0xBA
330:           }
0DB4  0008     RETURN
331:           
332:           
333:           static i2c1_fsm_states_t I2C1_DO_IDLE(void)
334:           {
335:               I2C1_Status.busy = false;
0A0B  0141     MOVLB 0x1
0A0C  10BC     BCF 0xBC, 0x1
336:               I2C1_Status.error = I2C1_NOERR;
0A0D  01BB     CLRF 0xBB
337:               return I2C1_RESET;
0A0E  300E     MOVLW 0xE
338:           }
0A0F  0008     RETURN
339:           
340:           static i2c1_fsm_states_t I2C1_DO_SEND_ADR_READ(void)
341:           {
342:               I2C1_Status.addressNackCheck = 1;
0A40  0141     MOVLB 0x1
0A41  143C     BSF 0xBC, 0x0
343:               I2C1_MasterSendTxData((uint8_t) (I2C1_Status.address << 1 | 1));
0A42  1403     BSF STATUS, 0x0
0A43  0D36     RLF 0xB6, W
0A44  318A     MOVLP 0xA
0A45  2206     CALL 0x206
344:               return I2C1_RCEN;
0A46  3005     MOVLW 0x5
345:           }
0A47  0008     RETURN
346:           
347:           static i2c1_fsm_states_t I2C1_DO_SEND_ADR_WRITE(void)
348:           {
349:               I2C1_Status.addressNackCheck = 1;
0A39  0141     MOVLB 0x1
0A3A  143C     BSF 0xBC, 0x0
350:               I2C1_MasterSendTxData((uint8_t) (I2C1_Status.address << 1));
0A3B  3536     LSLF 0xB6, W
0A3C  318A     MOVLP 0xA
0A3D  2206     CALL 0x206
351:               return I2C1_TX;
0A3E  3003     MOVLW 0x3
352:           }
0A3F  0008     RETURN
353:           
354:           static i2c1_fsm_states_t I2C1_DO_TX(void)
355:           {
356:               if(I2C1_MasterIsNack())
068B  318A     MOVLP 0xA
068C  2215     CALL 0x215
068D  3186     MOVLP 0x6
068E  3A00     XORLW 0x0
068F  1D03     BTFSS STATUS, 0x2
0690  2E9B     GOTO 0x69B
0691  2EC0     GOTO 0x6C0
357:               {
358:                   switch(I2C1_Status.callbackTable[I2C1_DATA_NACK](I2C1_Status.callbackPayload[I2C1_DATA_NACK]))
359:                   {
360:                       case I2C1_RESTART_READ:
361:                           return I2C1_DO_SEND_RESTART_READ();
0692  3189     MOVLP 0x9
0693  21DD     CALL 0x1DD
0694  0008     RETURN
362:                       case I2C1_RESTART_WRITE:
363:                             return I2C1_DO_SEND_RESTART_WRITE();
0695  3189     MOVLP 0x9
0696  21E1     CALL 0x1E1
0697  0008     RETURN
364:                       default:
365:                       case I2C1_CONTINUE:
366:                       case I2C1_STOP:
367:                           return I2C1_DO_SEND_STOP();
0698  3189     MOVLP 0x9
0699  21E9     CALL 0x1E9
069A  0008     RETURN
368:                   }
069B  0141     MOVLB 0x1
069C  082F     MOVF 0xAF, W
069D  0140     MOVLB 0x0
069E  00CB     MOVWF __pcstackBANK0
069F  084B     MOVF __pcstackBANK0, W
06A0  00FA     MOVWF readValLow
06A1  3006     MOVLW 0x6
06A2  3EA0     ADDLW 0xA0
06A3  0086     MOVWF FSR1
06A4  0187     CLRF FSR1H
06A5  3F41     MOVIW [1]FSR1
06A6  008A     MOVWF PCLATH
06A7  3F40     MOVIW [0]FSR1
06A8  000A     CALLW
06A9  3186     MOVLP 0x6
06AA  0140     MOVLB 0x0
06AB  00CC     MOVWF sign
06AC  01CD     CLRF quotient
06AD  084D     MOVF quotient, W
06AE  3A00     XORLW 0x0
06AF  1903     BTFSC STATUS, 0x2
06B0  2EB2     GOTO 0x6B2
06B1  2E98     GOTO 0x698
06B2  084C     MOVF sign, W
06B3  3A01     XORLW 0x1
06B4  1903     BTFSC STATUS, 0x2
06B5  2E98     GOTO 0x698
06B6  3A03     XORLW 0x3
06B7  1903     BTFSC STATUS, 0x2
06B8  2E92     GOTO 0x692
06B9  3A01     XORLW 0x1
06BA  1903     BTFSC STATUS, 0x2
06BB  2E95     GOTO 0x695
06BC  3A07     XORLW 0x7
06BD  1903     BTFSC STATUS, 0x2
06BE  2E98     GOTO 0x698
06BF  2E98     GOTO 0x698
369:               }
370:               else
371:               {
372:                   I2C1_Status.addressNackCheck = 0;
06C0  0141     MOVLB 0x1
06C1  103C     BCF 0xBC, 0x0
373:                   I2C1_MasterSendTxData(*I2C1_Status.data_ptr++);
06C2  3017     MOVLW 0x17
06C3  3EA0     ADDLW 0xA0
06C4  0086     MOVWF FSR1L
06C5  0187     CLRF FSR1H
06C6  3F40     MOVIW [0]FSR1
06C7  0084     MOVWF FSR0L
06C8  0185     CLRF FSR0H
06C9  0A81     INCF INDF1, F
06CA  0800     MOVF INDF0, W
06CB  318A     MOVLP 0xA
06CC  2206     CALL 0x206
06CD  3186     MOVLP 0x6
374:                   return (--I2C1_Status.data_length)?I2C1_TX:I2C1_TX_EMPTY;
06CE  3001     MOVLW 0x1
06CF  0141     MOVLB 0x1
06D0  02B8     SUBWF 0xB8, F
06D1  3000     MOVLW 0x0
06D2  3BB9     SUBWFB 0xB9, F
06D3  0838     MOVF 0xB8, W
06D4  0439     IORWF 0xB9, W
06D5  1D03     BTFSS STATUS, 0x2
06D6  2ED9     GOTO 0x6D9
06D7  3006     MOVLW 0x6
06D8  0008     RETURN
06D9  3003     MOVLW 0x3
375:               }
376:           }
06DA  0008     RETURN
377:           
378:           static i2c1_fsm_states_t I2C1_DO_RX(void)
379:           {
380:               *I2C1_Status.data_ptr++ = I2C1_MasterGetRxData();
06DB  3189     MOVLP 0x9
06DC  21CB     CALL 0x1CB
06DD  3186     MOVLP 0x6
06DE  0140     MOVLB 0x0
06DF  00CB     MOVWF __pcstackBANK0
06E0  0141     MOVLB 0x1
06E1  0837     MOVF 0xB7, W
06E2  0086     MOVWF FSR1L
06E3  0187     CLRF FSR1H
06E4  0140     MOVLB 0x0
06E5  084B     MOVF __pcstackBANK0, W
06E6  0081     MOVWF INDF1
06E7  3001     MOVLW 0x1
06E8  00CB     MOVWF __pcstackBANK0
06E9  084B     MOVF __pcstackBANK0, W
06EA  0141     MOVLB 0x1
06EB  07B7     ADDWF 0xB7, F
381:               if(--I2C1_Status.data_length)
06EC  3001     MOVLW 0x1
06ED  02B8     SUBWF 0xB8, F
06EE  3000     MOVLW 0x0
06EF  3BB9     SUBWFB 0xB9, F
06F0  0838     MOVF 0xB8, W
06F1  0439     IORWF 0xB9, W
06F2  1903     BTFSC STATUS, 0x2
06F3  2EF8     GOTO 0x6F8
382:               {
383:                   I2C1_MasterSendAck();
06F4  3189     MOVLP 0x9
06F5  21D9     CALL 0x1D9
384:                   return I2C1_RCEN;
06F6  3005     MOVLW 0x5
06F7  0008     RETURN
385:               }
386:               else
387:               {
388:                   I2C1_Status.bufferFree = true;
06F8  15BC     BSF 0xBC, 0x3
389:                   switch(I2C1_Status.callbackTable[I2C1_DATA_COMPLETE](I2C1_Status.callbackPayload[I2C1_DATA_COMPLETE]))
06F9  2F00     GOTO 0x700
390:                   {
391:                       case I2C1_RESTART_WRITE:
392:                       case I2C1_RESTART_READ:
393:                           return I2C1_DO_RX_NACK_RESTART();
06FA  3189     MOVLP 0x9
06FB  21F5     CALL 0x1F5
06FC  0008     RETURN
394:                       default:
395:                       case I2C1_CONTINUE:
396:                       case I2C1_STOP:
397:                           return I2C1_DO_RX_NACK_STOP();
06FD  3189     MOVLP 0x9
06FE  21F1     CALL 0x1F1
06FF  0008     RETURN
398:                   }
0700  082C     MOVF 0xAC, W
0701  0140     MOVLB 0x0
0702  00CB     MOVWF __pcstackBANK0
0703  084B     MOVF __pcstackBANK0, W
0704  00FA     MOVWF readValLow
0705  0141     MOVLB 0x1
0706  0821     MOVF 0xA1, W
0707  008A     MOVWF PCLATH
0708  0820     MOVF I2C1_Status, W
0709  000A     CALLW
070A  3187     MOVLP 0x7
070B  0140     MOVLB 0x0
070C  00CC     MOVWF sign
070D  01CD     CLRF quotient
070E  084D     MOVF quotient, W
070F  3A00     XORLW 0x0
0710  1903     BTFSC STATUS, 0x2
0711  2F13     GOTO 0x713
0712  2EFD     GOTO 0x6FD
0713  084C     MOVF sign, W
0714  3A01     XORLW 0x1
0715  1903     BTFSC STATUS, 0x2
0716  2EFD     GOTO 0x6FD
0717  3A03     XORLW 0x3
0718  1903     BTFSC STATUS, 0x2
0719  2EFA     GOTO 0x6FA
071A  3A01     XORLW 0x1
071B  1903     BTFSC STATUS, 0x2
071C  2EFA     GOTO 0x6FA
071D  3A07     XORLW 0x7
071E  1903     BTFSC STATUS, 0x2
071F  2EFD     GOTO 0x6FD
0720  2EFD     GOTO 0x6FD
399:               }
400:           }
0721  0008     RETURN
401:           
402:           static i2c1_fsm_states_t I2C1_DO_RCEN(void)
403:           {
404:               I2C1_Status.addressNackCheck = 0;
0A1B  0141     MOVLB 0x1
0A1C  103C     BCF 0xBC, 0x0
405:               I2C1_MasterStartRx();
0A1D  3189     MOVLP 0x9
0A1E  21C8     CALL 0x1C8
406:               return I2C1_RX;
0A1F  3004     MOVLW 0x4
407:           }
0A20  0008     RETURN
408:           
409:           static i2c1_fsm_states_t I2C1_DO_TX_EMPTY(void)
410:           {
411:               I2C1_Status.bufferFree = true;
0E40  0141     MOVLB 0x1
0E41  15BC     BSF 0xBC, 0x3
412:               switch(I2C1_Status.callbackTable[I2C1_DATA_COMPLETE](I2C1_Status.callbackPayload[I2C1_DATA_COMPLETE]))
0E42  2E4D     GOTO 0x64D
413:               {
414:                   case I2C1_RESTART_READ:
415:                   case I2C1_RESTART_WRITE:
416:                       return I2C1_DO_SEND_RESTART();
0E43  3189     MOVLP 0x9
0E44  21E5     CALL 0x1E5
0E45  0008     RETURN
417:                   case I2C1_CONTINUE:
418:                       I2C1_MasterSetIrq();
0E46  3189     MOVLP 0x9
0E47  21CE     CALL 0x1CE
419:                       return I2C1_TX;
0E48  3003     MOVLW 0x3
0E49  0008     RETURN
420:                   default:
421:                   case I2C1_STOP:
422:                       return I2C1_DO_SEND_STOP();
0E4A  3189     MOVLP 0x9
0E4B  21E9     CALL 0x1E9
0E4C  0008     RETURN
423:               }
0E4D  082C     MOVF 0xAC, W
0E4E  0140     MOVLB 0x0
0E4F  00CB     MOVWF __pcstackBANK0
0E50  084B     MOVF __pcstackBANK0, W
0E51  00FA     MOVWF readValLow
0E52  0141     MOVLB 0x1
0E53  0821     MOVF 0xA1, W
0E54  008A     MOVWF PCLATH
0E55  0820     MOVF I2C1_Status, W
0E56  000A     CALLW
0E57  318E     MOVLP 0xE
0E58  0140     MOVLB 0x0
0E59  00CC     MOVWF sign
0E5A  01CD     CLRF quotient
0E5B  084D     MOVF quotient, W
0E5C  3A00     XORLW 0x0
0E5D  1903     BTFSC STATUS, 0x2
0E5E  2E60     GOTO 0x660
0E5F  2E4A     GOTO 0x64A
0E60  084C     MOVF sign, W
0E61  3A01     XORLW 0x1
0E62  1903     BTFSC STATUS, 0x2
0E63  2E4A     GOTO 0x64A
0E64  3A03     XORLW 0x3
0E65  1903     BTFSC STATUS, 0x2
0E66  2E43     GOTO 0x643
0E67  3A01     XORLW 0x1
0E68  1903     BTFSC STATUS, 0x2
0E69  2E43     GOTO 0x643
0E6A  3A07     XORLW 0x7
0E6B  1903     BTFSC STATUS, 0x2
0E6C  2E46     GOTO 0x646
0E6D  2E4A     GOTO 0x64A
424:           }
0E6E  0008     RETURN
425:           
426:           static i2c1_fsm_states_t I2C1_DO_RX_EMPTY(void)
427:           {
428:               I2C1_Status.bufferFree = true;
429:               switch(I2C1_Status.callbackTable[I2C1_DATA_COMPLETE](I2C1_Status.callbackPayload[I2C1_DATA_COMPLETE]))
430:               {
431:                   case I2C1_RESTART_WRITE:
432:                       I2C1_MasterEnableRestart();
433:                       return I2C1_SEND_RESTART_WRITE;
434:                   case I2C1_RESTART_READ:
435:                       I2C1_MasterEnableRestart();
436:                       return I2C1_SEND_RESTART_READ;
437:                   case I2C1_CONTINUE:
438:                       // Avoid the counter stop condition , Counter is incremented by 1
439:                       return I2C1_RX;
440:                   default:
441:                   case I2C1_STOP:
442:                       if(I2C1_Status.state != I2C1_SEND_RESTART_READ)
443:                       {
444:                           I2C1_MasterDisableRestart();
445:                       }
446:                       return I2C1_RESET;
447:               }
448:           }
449:           
450:           static i2c1_fsm_states_t I2C1_DO_SEND_RESTART_READ(void)
451:           {
452:               I2C1_MasterEnableRestart();
09DD  3189     MOVLP 0x9
09DE  21C2     CALL 0x1C2
453:               return I2C1_SEND_ADR_READ;
09DF  3001     MOVLW 0x1
454:           }
09E0  0008     RETURN
455:           
456:           static i2c1_fsm_states_t I2C1_DO_SEND_RESTART_WRITE(void)
457:           {
458:               I2C1_MasterEnableRestart();
09E1  3189     MOVLP 0x9
09E2  21C2     CALL 0x1C2
459:               return I2C1_SEND_ADR_WRITE;
09E3  3002     MOVLW 0x2
460:           }
09E4  0008     RETURN
461:           
462:           
463:           static i2c1_fsm_states_t I2C1_DO_SEND_RESTART(void)
464:           {
465:               I2C1_MasterEnableRestart();
09E5  3189     MOVLP 0x9
09E6  21C2     CALL 0x1C2
466:               return I2C1_SEND_ADR_READ;
09E7  3001     MOVLW 0x1
467:           }
09E8  0008     RETURN
468:           
469:           static i2c1_fsm_states_t I2C1_DO_SEND_STOP(void)
470:           {
471:               I2C1_MasterStop();
09E9  3189     MOVLP 0x9
09EA  21C5     CALL 0x1C5
472:               return I2C1_IDLE;
09EB  3000     MOVLW 0x0
473:           }
09EC  0008     RETURN
474:           
475:           static i2c1_fsm_states_t I2C1_DO_RX_ACK(void)
476:           {
477:               I2C1_MasterSendAck();
09ED  3189     MOVLP 0x9
09EE  21D9     CALL 0x1D9
478:               return I2C1_RCEN;
09EF  3005     MOVLW 0x5
479:           }
09F0  0008     RETURN
480:           
481:           
482:           static i2c1_fsm_states_t I2C1_DO_RX_NACK_STOP(void)
483:           {
484:               I2C1_MasterSendNack();
09F1  3189     MOVLP 0x9
09F2  21D5     CALL 0x1D5
485:               return I2C1_SEND_STOP;
09F3  300A     MOVLW 0xA
486:           }
09F4  0008     RETURN
487:           
488:           static i2c1_fsm_states_t I2C1_DO_RX_NACK_RESTART(void)
489:           {
490:               I2C1_MasterSendNack();
09F5  3189     MOVLP 0x9
09F6  21D5     CALL 0x1D5
491:               return I2C1_SEND_RESTART;
09F7  3009     MOVLW 0x9
492:           }
09F8  0008     RETURN
493:           
494:           static i2c1_fsm_states_t I2C1_DO_RESET(void)
495:           {
496:               I2C1_Status.busy = false;
0A10  0141     MOVLB 0x1
0A11  10BC     BCF 0xBC, 0x1
497:               I2C1_Status.error = I2C1_NOERR;
0A12  01BB     CLRF 0xBB
498:               return I2C1_RESET;
0A13  300E     MOVLW 0xE
499:           }
0A14  0008     RETURN
500:           static i2c1_fsm_states_t I2C1_DO_ADDRESS_NACK(void)
501:           {
502:               I2C1_Status.addressNackCheck = 0;
0DB5  0141     MOVLB 0x1
0DB6  103C     BCF 0xBC, 0x0
503:               I2C1_Status.error = I2C1_FAIL;
0DB7  3002     MOVLW 0x2
0DB8  0140     MOVLB 0x0
0DB9  00CB     MOVWF __pcstackBANK0
0DBA  084B     MOVF __pcstackBANK0, W
0DBB  0141     MOVLB 0x1
0DBC  00BB     MOVWF 0xBB
504:               switch(I2C1_Status.callbackTable[I2C1_ADDR_NACK](I2C1_Status.callbackPayload[I2C1_ADDR_NACK]))
0DBD  2DC4     GOTO 0x5C4
505:               {
506:                   case I2C1_RESTART_READ:
507:                   case I2C1_RESTART_WRITE:
508:                       return I2C1_DO_SEND_RESTART();
0DBE  3189     MOVLP 0x9
0DBF  21E5     CALL 0x1E5
0DC0  0008     RETURN
509:                   default:
510:                       return I2C1_DO_SEND_STOP();
0DC1  3189     MOVLP 0x9
0DC2  21E9     CALL 0x1E9
0DC3  0008     RETURN
511:               }
0DC4  082E     MOVF 0xAE, W
0DC5  0140     MOVLB 0x0
0DC6  00CB     MOVWF __pcstackBANK0
0DC7  084B     MOVF __pcstackBANK0, W
0DC8  00FA     MOVWF readValLow
0DC9  3004     MOVLW 0x4
0DCA  3EA0     ADDLW 0xA0
0DCB  0086     MOVWF FSR1
0DCC  0187     CLRF FSR1H
0DCD  3F41     MOVIW [1]FSR1
0DCE  008A     MOVWF PCLATH
0DCF  3F40     MOVIW [0]FSR1
0DD0  000A     CALLW
0DD1  318D     MOVLP 0xD
0DD2  0140     MOVLB 0x0
0DD3  00CC     MOVWF sign
0DD4  01CD     CLRF quotient
0DD5  084D     MOVF quotient, W
0DD6  3A00     XORLW 0x0
0DD7  1903     BTFSC STATUS, 0x2
0DD8  2DDA     GOTO 0x5DA
0DD9  2DC1     GOTO 0x5C1
0DDA  084C     MOVF sign, W
0DDB  3A02     XORLW 0x2
0DDC  1903     BTFSC STATUS, 0x2
0DDD  2DBE     GOTO 0x5BE
0DDE  3A01     XORLW 0x1
0DDF  1903     BTFSC STATUS, 0x2
0DE0  2DBE     GOTO 0x5BE
0DE1  2DC1     GOTO 0x5C1
512:           }
0DE2  0008     RETURN
513:           
514:           void I2C1_BusCollisionIsr(void)
515:           {
516:               I2C1_MasterClearBusCollision();
517:               I2C1_Status.state = I2C1_RESET;
518:           }
519:           
520:           i2c1_operations_t I2C1_CallbackReturnStop(void *funPtr)
521:           {
522:               return I2C1_STOP;
09AF  3001     MOVLW 0x1
523:           }
09B0  0008     RETURN
524:           
525:           i2c1_operations_t I2C1_CallbackReturnReset(void *funPtr)
526:           {
527:               return I2C1_RESET_LINK;
09B1  3005     MOVLW 0x5
528:           }
09B2  0008     RETURN
529:           
530:           i2c1_operations_t I2C1_CallbackRestartWrite(void *funPtr)
531:           {
532:               return I2C1_RESTART_WRITE;
533:           }
534:           
535:           i2c1_operations_t I2C1_CallbackRestartRead(void *funPtr)
536:           {
537:               return I2C1_RESTART_READ;
538:           }
539:           
540:           
541:           
542:           /* I2C1 Register Level interfaces */
543:           static inline bool I2C1_MasterOpen(void)
544:           {
545:               if(!SSP1CON1bits.SSPEN)
0A8C  0143     MOVLB 0x3
0A8D  1A90     BTFSC SSP1CON1, 0x5
0A8E  0008     RETURN
546:               {
547:                   SSP1STAT = 0x00;
0A8F  018F     CLRF SSP1STAT
548:                   SSP1CON1 = 0x08;
0A90  3008     MOVLW 0x8
0A91  0090     MOVWF SSP1CON1
549:                   SSP1CON2 = 0x00;
0A92  0191     CLRF SSP1CON2
550:                   SSP1ADD = 0x09;
0A93  3009     MOVLW 0x9
0A94  008D     MOVWF SSP1ADD
551:                   SSP1CON1bits.SSPEN = 1;
0A95  1690     BSF SSP1CON1, 0x5
552:                   return true;
553:               }
554:               return false;
555:           }
0A96  0008     RETURN
556:           
557:           static inline void I2C1_MasterClose(void)
558:           {
559:               //Disable I2C1
560:               SSP1CON1bits.SSPEN = 0;
09BC  0143     MOVLB 0x3
09BD  1290     BCF SSP1CON1, 0x5
561:           }
09BE  0008     RETURN
562:           
563:           static inline uint8_t I2C1_MasterGetRxData(void)
564:           {
565:               return SSP1BUF;
09CB  0143     MOVLB 0x3
09CC  080C     MOVF SSP1BUF, W
566:           }
09CD  0008     RETURN
567:           
568:           static inline void I2C1_MasterSendTxData(uint8_t data)
0A06  00F1     MOVWF 0x1F1
569:           {
570:               SSP1BUF  = data;
0A07  0871     MOVF 0x1F1, W
0A08  0143     MOVLB 0x3
0A09  008C     MOVWF SSP1BUF
571:           }
0A0A  0008     RETURN
572:           
573:           static inline void I2C1_MasterEnableRestart(void)
574:           {
575:               SSP1CON2bits.RSEN = 1;
09C2  0143     MOVLB 0x3
09C3  1491     BSF SSP1CON2, 0x1
576:           }
09C4  0008     RETURN
577:           
578:           static inline void I2C1_MasterDisableRestart(void)
579:           {
580:               SSP1CON2bits.RSEN = 0;
581:           }
582:           
583:           static inline void I2C1_MasterStartRx(void)
584:           {
585:               SSP1CON2bits.RCEN = 1;
09C8  0143     MOVLB 0x3
09C9  1591     BSF SSP1CON2, 0x3
586:           }
09CA  0008     RETURN
587:           
588:           static inline void I2C1_MasterStart(void)
589:           {
590:               SSP1CON2bits.SEN = 1;
09BF  0143     MOVLB 0x3
09C0  1411     BSF SSP1CON2, 0x0
591:           }
09C1  0008     RETURN
592:           
593:           static inline void I2C1_MasterStop(void)
594:           {
595:               SSP1CON2bits.PEN = 1;
09C5  0143     MOVLB 0x3
09C6  1511     BSF SSP1CON2, 0x2
596:           }
09C7  0008     RETURN
597:           
598:           static inline bool I2C1_MasterIsNack(void)
599:           {
600:               return SSP1CON2bits.ACKSTAT;
0A15  0143     MOVLB 0x3
0A16  0E11     SWAPF SSP1CON2, W
0A17  0C89     RRF WREG, F
0A18  0C89     RRF WREG, F
0A19  3901     ANDLW 0x1
601:           }
0A1A  0008     RETURN
602:           
603:           static inline void I2C1_MasterSendAck(void)
604:           {
605:               SSP1CON2bits.ACKDT = 0;
09D9  0143     MOVLB 0x3
09DA  1291     BCF SSP1CON2, 0x5
606:               SSP1CON2bits.ACKEN = 1;
09DB  1611     BSF SSP1CON2, 0x4
607:           }
09DC  0008     RETURN
608:           
609:           static inline void I2C1_MasterSendNack(void)
610:           {
611:               SSP1CON2bits.ACKDT = 1;
09D5  0143     MOVLB 0x3
09D6  1691     BSF SSP1CON2, 0x5
612:               SSP1CON2bits.ACKEN = 1;
09D7  1611     BSF SSP1CON2, 0x4
613:           }
09D8  0008     RETURN
614:           
615:           static inline void I2C1_MasterClearBusCollision(void)
616:           {
617:               PIR3bits.BCL1IF = 0;
618:           }
619:           
620:           static inline bool I2C1_MasterIsRxBufFull(void)
621:           {
622:               return SSP1STATbits.BF;
623:           }
624:           
625:           static inline void I2C1_MasterEnableIrq(void)
626:           {
627:               PIE3bits.SSP1IE = 1;
628:           }
629:           
630:           static inline bool I2C1_MasterIsIrqEnabled(void)
631:           {
632:               return PIE3bits.SSP1IE;
633:           }
634:           
635:           static inline void I2C1_MasterDisableIrq(void)
636:           {
637:               PIE3bits.SSP1IE = 0;
09AD  1019     BCF 0x199, 0x0
638:           }
09AE  0008     RETURN
639:           
640:           static inline void I2C1_MasterClearIrq(void)
641:           {
642:               PIR3bits.SSP1IF = 0;
09B9  014E     MOVLB 0xE
09BA  100F     BCF PIR3, 0x0
643:           }
09BB  0008     RETURN
644:           
645:           static inline void I2C1_MasterSetIrq(void)
646:           {
647:               PIR3bits.SSP1IF = 1;
09CE  014E     MOVLB 0xE
09CF  140F     BSF PIR3, 0x0
648:           }
09D0  0008     RETURN
649:           
650:           static inline void I2C1_MasterWaitForEvent(void)
651:           {
652:               while(1)
653:               {
654:                   if(PIR3bits.SSP1IF)
09F9  014E     MOVLB 0xE
09FA  180F     BTFSC PIR3, 0x0
09FB  0008     RETURN
655:                   {    
656:                       break;
657:                   }
658:               }
659:           }
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/mcc_generated_files/drivers/i2c_simple_master.c
1:             /**
2:             \file
3:             \addtogroup doc_driver_i2c_code
4:             \brief This file provides some basic blocking helper functions for common operations on the I2C API
5:             
6:             \copyright (c) 2020 Microchip Technology Inc. and its subsidiaries.
7:             \page License
8:                 (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
9:                 software and any derivatives exclusively with Microchip products.
10:            
11:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
12:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
13:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
14:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
15:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
16:            
17:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
18:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
19:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
20:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
21:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
22:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
23:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
24:            
25:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
26:                TERMS.
27:            */
28:            
29:            
30:            #include ".././i2c1_master.h"
31:            #include "i2c_simple_master.h"
32:            
33:            /****************************************************************/
34:            static i2c1_operations_t wr1RegCompleteHandler(void *p)
35:            {
36:                I2C1_SetBuffer(p,1);
0B17  3001     MOVLW 0x1
0B18  00F1     MOVWF 0x771
0B19  3000     MOVLW 0x0
0B1A  00F2     MOVWF 0x772
0B1B  087A     MOVF 0x77A, W
0B1C  318A     MOVLP 0xA
0B1D  22EB     CALL 0x2EB
0B1E  318B     MOVLP 0xB
37:                I2C1_SetDataCompleteCallback(NULL,NULL);
0B1F  3000     MOVLW 0x0
0B20  00F6     MOVWF 0x776
0B21  00F7     MOVWF 0x777
0B22  01F8     CLRF 0x778
0B23  318A     MOVLP 0xA
0B24  22AF     CALL 0x2AF
38:                return I2C1_CONTINUE;
0B25  3004     MOVLW 0x4
39:            }
0B26  0008     RETURN
40:            
41:            /**
42:             *  \ingroup doc_driver_i2c_code
43:             *  \brief Function to write 1 byte of data to a register location
44:             *  
45:             *  \param [in] address [type]i2c_address_t The slave address
46:             *         [in] reg     [type]uint8_t The register address to be written to
47:             *         [in] data    [type]uint8_t The data to be written
48:             *  
49:             *  \return None
50:             */
51:            void i2c_write1ByteRegister(i2c1_address_t address, uint8_t reg, uint8_t data)
0DE3  00D6     MOVWF 0x756
52:            {
53:                while(!I2C1_Open(address)); // sit here until we get the bus..
0DE4  0140     MOVLB 0x0
0DE5  0856     MOVF e, W
0DE6  318F     MOVLP 0xF
0DE7  270B     CALL 0x70B
0DE8  318D     MOVLP 0xD
0DE9  3A00     XORLW 0x0
0DEA  1903     BTFSC STATUS, 0x2
0DEB  2DE4     GOTO 0x5E4
54:                I2C1_SetDataCompleteCallback(wr1RegCompleteHandler,&data);
0DEC  3017     MOVLW 0x17
0DED  00F6     MOVWF cb
0DEE  300B     MOVLW 0xB
0DEF  00F7     MOVWF divisor
0DF0  3054     MOVLW 0x54
0DF1  0140     MOVLB 0x0
0DF2  00D5     MOVWF divisor
0DF3  0855     MOVF divisor, W
0DF4  00F8     MOVWF readVal
0DF5  318A     MOVLP 0xA
0DF6  22AF     CALL 0x2AF
0DF7  318D     MOVLP 0xD
55:                I2C1_SetBuffer(&reg,1);
0DF8  3001     MOVLW 0x1
0DF9  00F1     MOVWF data
0DFA  3000     MOVLW 0x0
0DFB  00F2     MOVWF input
0DFC  3053     MOVLW 0x53
0DFD  318A     MOVLP 0xA
0DFE  22EB     CALL 0x2EB
0DFF  318D     MOVLP 0xD
56:                I2C1_SetAddressNackCallback(NULL,NULL); //NACK polling?
0E00  3000     MOVLW 0x0
0E01  00F6     MOVWF cb
0E02  00F7     MOVWF divisor
0E03  01F8     CLRF readVal
0E04  318A     MOVLP 0xA
0E05  22BB     CALL 0x2BB
0E06  318D     MOVLP 0xD
57:                I2C1_MasterWrite();
0E07  3189     MOVLP 0x9
0E08  21FD     CALL 0x1FD
0E09  318D     MOVLP 0xD
58:                while(I2C1_BUSY == I2C1_Close()); // sit here until finished.
0E0A  318C     MOVLP 0xC
0E0B  243A     CALL 0x43A
0E0C  318D     MOVLP 0xD
0E0D  3A01     XORLW 0x1
0E0E  1D03     BTFSS STATUS, 0x2
0E0F  0008     RETURN
59:            }
60:            
61:            /**
62:             *  \ingroup doc_driver_i2c_code
63:             *  \brief Function to write N byte of data 
64:             *  
65:             *  \param [in] address [type]i2c_address_t Slave address
66:             *         [in] data    [type]uint8_t Array of data to be send
67:             *         [in] len     [type]uint8_t The size of the array
68:             *  
69:             *  \return None
70:             */
71:            void i2c_writeNBytes(i2c1_address_t address, void* data, size_t len)
72:            {
73:                while(!I2C1_Open(address)); // sit here until we get the bus..
74:                I2C1_SetBuffer(data,len);
75:                I2C1_SetAddressNackCallback(NULL,NULL); //NACK polling?
76:                I2C1_MasterWrite();
77:                while(I2C1_BUSY == I2C1_Close()); // sit here until finished.
78:            }
79:            
80:            /****************************************************************/
81:            static i2c1_operations_t rd1RegCompleteHandler(void *p)
82:            {
83:                I2C1_SetBuffer(p,1);
0B27  3001     MOVLW 0x1
0B28  00F1     MOVWF data
0B29  3000     MOVLW 0x0
0B2A  00F2     MOVWF input
0B2B  087A     MOVF readValLow, W
0B2C  318A     MOVLP 0xA
0B2D  22EB     CALL 0x2EB
0B2E  318B     MOVLP 0xB
84:                I2C1_SetDataCompleteCallback(NULL,NULL);
0B2F  3000     MOVLW 0x0
0B30  00F6     MOVWF cb
0B31  00F7     MOVWF divisor
0B32  01F8     CLRF readVal
0B33  318A     MOVLP 0xA
0B34  22AF     CALL 0x2AF
85:                return I2C1_RESTART_READ;
0B35  3002     MOVLW 0x2
86:            }
0B36  0008     RETURN
87:            
88:            /**
89:             *  \ingroup doc_driver_i2c_code
90:             *  \brief Function to read 1 byte of data from a register location
91:             *  
92:             *  \param [in] address [type]i2c_address_t Slave address
93:             *         [in] reg     [type]uint8_t The register address to be read
94:             *  
95:             *  \return [out] The read data byte
96:             */
97:            uint8_t i2c_read1ByteRegister(i2c1_address_t address, uint8_t reg)
0722  00D5     MOVWF divisor
98:            {
99:                uint8_t    d2=42;
0723  302A     MOVLW 0x2A
0724  00D4     MOVWF data
0725  0854     MOVF data, W
0726  00D9     MOVWF eeaddr
100:               i2c1_error_t e;
101:               int x;
102:           
103:               for(x = 2; x != 0; x--)
0727  3002     MOVLW 0x2
0728  00D7     MOVWF regp
0729  3000     MOVLW 0x0
072A  00D8     MOVWF min
104:               {
105:                   while(!I2C1_Open(address)); // sit here until we get the bus..
072B  0140     MOVLB 0x0
072C  0855     MOVF divisor, W
072D  318F     MOVLP 0xF
072E  270B     CALL 0x70B
072F  3187     MOVLP 0x7
0730  3A00     XORLW 0x0
0731  1903     BTFSC STATUS, 0x2
0732  2F2B     GOTO 0x72B
106:                   I2C1_SetDataCompleteCallback(rd1RegCompleteHandler,&d2);
0733  3027     MOVLW 0x27
0734  00F6     MOVWF cb
0735  300B     MOVLW 0xB
0736  00F7     MOVWF divisor
0737  3059     MOVLW 0x59
0738  0140     MOVLB 0x0
0739  00D4     MOVWF data
073A  0854     MOVF data, W
073B  00F8     MOVWF readVal
073C  318A     MOVLP 0xA
073D  22AF     CALL 0x2AF
073E  3187     MOVLP 0x7
107:                   I2C1_SetBuffer(&reg,1);
073F  3001     MOVLW 0x1
0740  00F1     MOVWF data
0741  3000     MOVLW 0x0
0742  00F2     MOVWF input
0743  3053     MOVLW 0x53
0744  318A     MOVLP 0xA
0745  22EB     CALL 0x2EB
0746  3187     MOVLP 0x7
108:                   I2C1_SetAddressNackCallback(NULL,NULL); //NACK polling?
0747  3000     MOVLW 0x0
0748  00F6     MOVWF cb
0749  00F7     MOVWF divisor
074A  01F8     CLRF readVal
074B  318A     MOVLP 0xA
074C  22BB     CALL 0x2BB
074D  3187     MOVLP 0x7
109:                   I2C1_MasterWrite();
074E  3189     MOVLP 0x9
074F  21FD     CALL 0x1FD
0750  3187     MOVLP 0x7
110:                   while(I2C1_BUSY == (e = I2C1_Close())); // sit here until finished.
0751  318C     MOVLP 0xC
0752  243A     CALL 0x43A
0753  3187     MOVLP 0x7
0754  0140     MOVLB 0x0
0755  00D4     MOVWF data
0756  0854     MOVF data, W
0757  00D6     MOVWF e
0758  0356     DECF e, W
0759  1903     BTFSC STATUS, 0x2
075A  2F51     GOTO 0x751
111:                   if(e==I2C1_NOERR) break;
075B  0856     MOVF e, W
075C  1903     BTFSC STATUS, 0x2
075D  2F66     GOTO 0x766
112:               }
075E  30FF     MOVLW 0xFF
075F  07D7     ADDWF regp, F
0760  30FF     MOVLW 0xFF
0761  3DD8     ADDWFC min, F
0762  0857     MOVF regp, W
0763  0458     IORWF min, W
0764  1D03     BTFSS STATUS, 0x2
0765  2F2B     GOTO 0x72B
113:               
114:           
115:               return d2;
0766  0859     MOVF eeaddr, W
116:           }
0767  0008     RETURN
117:           
118:           /****************************************************************/
119:           static i2c1_operations_t rd2RegCompleteHandler(void *p)
120:           {
121:               I2C1_SetBuffer(p,2);
0B37  3002     MOVLW 0x2
0B38  00F1     MOVWF data
0B39  3000     MOVLW 0x0
0B3A  00F2     MOVWF input
0B3B  087A     MOVF readValLow, W
0B3C  318A     MOVLP 0xA
0B3D  22EB     CALL 0x2EB
0B3E  318B     MOVLP 0xB
122:               I2C1_SetDataCompleteCallback(NULL,NULL);
0B3F  3000     MOVLW 0x0
0B40  00F6     MOVWF cb
0B41  00F7     MOVWF divisor
0B42  01F8     CLRF readVal
0B43  318A     MOVLP 0xA
0B44  22AF     CALL 0x2AF
123:               return I2C1_RESTART_READ;
0B45  3002     MOVLW 0x2
124:           }
0B46  0008     RETURN
125:           
126:           /**
127:            *  \ingroup doc_driver_i2c_code
128:            *  \brief Function to read 2 byte of data from a register location
129:            *  
130:            *  \param [in] address [type]i2c_address_t Slave address
131:            *         [in] reg     [type]uint8_t The register address to be read
132:            *  
133:            *  \return [out] The read 2 bytes of data
134:            */
135:           uint16_t i2c_read2ByteRegister(i2c1_address_t address, uint8_t reg)
136:           {
137:               // result is little endian
138:               uint16_t    result;
139:           
140:               while(!I2C1_Open(address)); // sit here until we get the bus..
141:               I2C1_SetDataCompleteCallback(rd2RegCompleteHandler,&result);
142:               I2C1_SetBuffer(&reg,1);
143:               I2C1_SetAddressNackCallback(NULL,NULL); //NACK polling?
144:               I2C1_MasterWrite();
145:               while(I2C1_BUSY == I2C1_Close()); // sit here until finished.
146:               
147:               return (result << 8 | result >> 8);
148:           }
149:           
150:           /****************************************************************/
151:           static i2c1_operations_t wr2RegCompleteHandler(void *p)
152:           {
153:               I2C1_SetBuffer(p,2);
0B07  3002     MOVLW 0x2
0B08  00F1     MOVWF data
0B09  3000     MOVLW 0x0
0B0A  00F2     MOVWF input
0B0B  087A     MOVF readValLow, W
0B0C  318A     MOVLP 0xA
0B0D  22EB     CALL 0x2EB
0B0E  318B     MOVLP 0xB
154:               I2C1_SetDataCompleteCallback(NULL,NULL);
0B0F  3000     MOVLW 0x0
0B10  00F6     MOVWF cb
0B11  00F7     MOVWF divisor
0B12  01F8     CLRF readVal
0B13  318A     MOVLP 0xA
0B14  22AF     CALL 0x2AF
155:               return I2C1_CONTINUE;
0B15  3004     MOVLW 0x4
156:           }
0B16  0008     RETURN
157:           
158:           /**
159:            *  \ingroup doc_driver_i2c_code
160:            *  \brief Function to write 1 byte of data to a register location
161:            *  
162:            *  \param [in] address [type]i2c_address_t The slave address
163:            *         [in] reg     [type]uint8_t The register address to be written to
164:            *         [in] data    [type]uint8_t The data to be written
165:            *  
166:            *  \return None
167:            */
168:           void i2c_write2ByteRegister(i2c1_address_t address, uint8_t reg, uint16_t data)
169:           {
170:               while(!I2C1_Open(address)); // sit here until we get the bus..
171:               I2C1_SetDataCompleteCallback(wr2RegCompleteHandler,&data);
172:               I2C1_SetBuffer(&reg,1);
173:               I2C1_SetAddressNackCallback(NULL,NULL); //NACK polling?
174:               I2C1_MasterWrite();
175:               while(I2C1_BUSY == I2C1_Close()); // sit here until finished.
176:           }
177:           
178:           /****************************************************************/
179:           typedef struct
180:           {
181:               size_t len;
182:               char *data;
183:           }buf_t;
184:           
185:           static i2c1_operations_t rdBlkRegCompleteHandler(void *p)
186:           {
187:               I2C1_SetBuffer(((buf_t *)p)->data,((buf_t*)p)->len);
0BF3  087A     MOVF readValLow, W
0BF4  0086     MOVWF FSR1
0BF5  0187     CLRF FSR1H
0BF6  3F40     MOVIW [0]FSR1
0BF7  00F1     MOVWF data
0BF8  3F41     MOVIW [1]FSR1
0BF9  00F2     MOVWF input
0BFA  087A     MOVF readValLow, W
0BFB  3E02     ADDLW 0x2
0BFC  0086     MOVWF FSR1
0BFD  0187     CLRF FSR1H
0BFE  0801     MOVF INDF1, W
0BFF  318A     MOVLP 0xA
0C00  22EB     CALL 0x2EB
0C01  318B     MOVLP 0xB
188:               I2C1_SetDataCompleteCallback(NULL,NULL);
0C02  3000     MOVLW 0x0
0C03  00F6     MOVWF cb
0C04  00F7     MOVWF divisor
0C05  01F8     CLRF readVal
0C06  318A     MOVLP 0xA
0C07  22AF     CALL 0x2AF
189:               return I2C1_RESTART_READ;
0C08  3002     MOVLW 0x2
190:           }
0C09  0008     RETURN
191:           
192:           /**
193:            *  \ingroup doc_driver_i2c_code
194:            *  \brief Function to read block of data from a register location
195:            *  
196:            *  \param [in] address [type]i2c_address_t Slave address
197:            *         [in] reg     [type]uint8_t The register address to be read
198:            *         [out] data   [type]void* The read data block
199:            *         [in] len     [type]size_t The size of data block
200:            *  
201:            *  \return None
202:            */
203:           void i2c_readDataBlock(i2c1_address_t address, uint8_t reg, void *data, size_t len)
204:           {
205:               // result is little endian
206:               buf_t    d;
207:               d.data = data;
208:               d.len = len;
209:           
210:               while(!I2C1_Open(address)); // sit here until we get the bus..
211:               I2C1_SetDataCompleteCallback(rdBlkRegCompleteHandler,&d);
212:               I2C1_SetBuffer(&reg,1);
213:               I2C1_SetAddressNackCallback(NULL,NULL); //NACK polling?
214:               I2C1_MasterWrite();
215:               while(I2C1_BUSY == I2C1_Close()); // sit here until finished.
216:           }
217:           
218:           /**
219:            *  \ingroup doc_driver_i2c_code
220:            *  \brief Function to read N bytes of data
221:            *  
222:            *  \param [in] address [type]i2c_address_t Slave address
223:            *         [out] data   [type]void* The read data block
224:            *         [in] len     [type]size_t The size of data block
225:            *  
226:            *  \return None
227:            */
228:           void i2c_readNBytes(i2c1_address_t address, void *data, size_t len)
229:           {
230:               while(!I2C1_Open(address)); // sit here until we get the bus..
231:               I2C1_SetBuffer(data,len);
232:               I2C1_MasterRead();
233:               while(I2C1_BUSY == I2C1_Close()); // sit here until finished.
234:           }
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/main.c  ----------------------
1:             /*
2:               Generated Main Source File
3:             
4:               File Name:
5:                 main.c
6:             
7:               Summary:
8:                 This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
9:                 Based on the orignal assembly source code created by Tom Titor of /a/ in 2012
10:                for the Divergence Meter project
11:            
12:              Original author:
13:               Tom Titor of /a/
14:              
15:              Rewrite author: 
16:                /u/xilyflob
17:            
18:              Version:
19:                0.05
20:            
21:              Description:
22:                This header file provides implementations for driver APIs for all modules selected in the GUI.
23:                Generation Information :
24:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
25:                    Device            :  PIC16F18444
26:                    Driver Version    :  2.00
27:            */
28:            
29:            /* Version History
30:             * 0.00 - Initial code rewrite, Initial MCC config
31:             * 0.05 - Initial code rewrite exceeded the program memory of the new device before
32:             *        even getting close to the end of the original program. Large areas
33:             *        completely rewritten, again, to produce better assembly code. MCC config
34:             *        had also been tweaked several times at this point
35:             */
36:            
37:            /* Conversion notes by the rewriter
38:             * 
39:             * As a general note, you can get the original .asm file to load into the modern
40:             * MPLABX. However the version of assembly code that is now used is "very" different
41:             * than what it was written in. Commands are juuuuust different enough to trip up
42:             * almost every line. For example andwf does not use w or f for the second operator
43:             * it uses 0 or 1 now and hex and binary numbers are called out differently. I am 
44:             * unsure if you can force the software to cram the .asm file into the chip as it
45:             * is, maybe the .hex file. I did not pursue this to any extent at all.
46:             * 
47:             * Several of the original subroutines are not recreated in this program. This is
48:             * due to their purpose being covered by things built into C or things created by
49:             * MCC. What follows is a list of subroutines that were not recreated:
50:             *  Anything I2C clock related - this is all handled by the MCC generated files
51:             *  Anything delay related - the delay foundation services now handle most of this
52:             *  The Get/FillT1T0 subroutine - I just did not use this
53:             * 
54:             * The VAST majority of the explicit variable registry call outs are not done due
55:             * to C not really needing that done expressly, it is handled between actual
56:             * variables and the compiler.
57:             * 
58:             * The EEPROM is slightly altered from its original form since I handled storage
59:             * and syntax of the display buffer differently. I also could not figure out how
60:             * to decode the original hex.
61:             * 
62:             * The blanking hours are now stored in EEPROM, even with the old processor there
63:             * was space in the EEPROM for these numbers. I believe they were stored there for
64:             * simplicity in altering the settings but I feel it opens it to data loss when
65:             * the backup battery dies.
66:             * 
67:             * Brightness control is now run by an honest to god hardware PWM generator, not
68:             * the admittedly effective, but messy and hard to understand software version that
69:             * was present in the original program
70:             * 
71:             * I could not understand how the slide flag affected the loader sub well enough
72:             * to be able to replicate it, thus I have come up with a different way to do the
73:             * same thing. Unfortunately due to this means that it is much less efficient.
74:             * 
75:             * I had wanted to not work in BCD for readability, but in an effort to reduce 
76:             * program size I had to do it in the end.
77:             * 
78:             * to determine how long a delay is, take the value and put a decimal point after
79:             * the second digit.
80:             */
81:            
82:            /*
83:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
84:                
85:                Subject to your compliance with these terms, you may use Microchip software and any 
86:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
87:                license terms applicable to your use of third party software (including open source software) that 
88:                may accompany Microchip software.
89:                
90:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
91:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
92:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
93:                FOR A PARTICULAR PURPOSE.
94:                
95:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
96:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
97:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
98:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
99:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
100:               CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
101:               OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
102:               SOFTWARE.
103:           */
104:           
105:           #include "mcc_generated_files/mcc.h"
106:           #include "Variables.h"
107:           #include "Subroutines.h"
108:           
109:           void Startup(void) //one time startup function
110:           {
111:               // DEVICE INITIALIZATION
112:               SYSTEM_Initialize(); //MCC generated startup
03CA  318C     MOVLP 0xC
03CB  2422     CALL 0x422
03CC  3183     MOVLP 0x3
113:               TMR0_StartTimer(); //start TMR0, it is used for the random number generator
03CD  3180     MOVLP 0x0
03CE  2002     CALL 0x2
03CF  3183     MOVLP 0x3
114:               //END DEVICE INITIALIZATION
115:           
116:               //PROGRAM INITIALIZATION
117:               //Interrupt Initialize (global is done later)
118:               INTERRUPT_PeripheralInterruptEnable();
03D0  170B     BSF INTCON, 0x6
119:               
120:               //Load EEPROM settings into RAM for fast access
121:               TimeFast = TimeFastStore; //time animation speed 
03D1  30F4     MOVLW 0xF4
03D2  318A     MOVLP 0xA
03D3  22D3     CALL 0x2D3
03D4  3183     MOVLP 0x3
03D5  0140     MOVLB 0x0
03D6  00DA     MOVWF value
03D7  085A     MOVF value, W
03D8  00BD     MOVWF TimeFast
122:               TimeAdj = TimeAdjStore; //time adjustment setting initialize
03D9  30F5     MOVLW 0xF5
03DA  318B     MOVLP 0xB
03DB  23A0     CALL 0x3A0
03DC  3183     MOVLP 0x3
03DD  0877     MOVF divisor, W
03DE  00AB     MOVWF 0x2B
03DF  0876     MOVF cb, W
03E0  00AA     MOVWF TimeAdj
123:               DateFormat = DateFormatStore; //date format setting initialize
03E1  30F7     MOVLW 0xF7
03E2  318A     MOVLP 0xA
03E3  22D3     CALL 0x2D3
03E4  3183     MOVLP 0x3
03E5  0140     MOVLB 0x0
03E6  00DA     MOVWF value
03E7  085A     MOVF value, W
03E8  00BC     MOVWF DateFormat
124:               Brightness = BrightnessStore; //brightness setting initialize
03E9  30F3     MOVLW 0xF3
03EA  318A     MOVLP 0xA
03EB  22D3     CALL 0x2D3
03EC  3183     MOVLP 0x3
03ED  0140     MOVLB 0x0
03EE  00DA     MOVWF value
03EF  085A     MOVF value, W
03F0  00BB     MOVWF Brightness
125:               HourType = HourTypeStore; //12/24 hour setting initialize
03F1  30F2     MOVLW 0xF2
03F2  318A     MOVLP 0xA
03F3  22D3     CALL 0x2D3
03F4  3183     MOVLP 0x3
03F5  0140     MOVLB 0x0
03F6  00DA     MOVWF value
03F7  085A     MOVF value, W
03F8  00BA     MOVWF HourType
126:               BlankStart = BlankStartStore; //blanking setting initialize
03F9  30F1     MOVLW 0xF1
03FA  318A     MOVLP 0xA
03FB  22D3     CALL 0x2D3
03FC  3183     MOVLP 0x3
03FD  0140     MOVLB 0x0
03FE  00DA     MOVWF value
03FF  085A     MOVF value, W
0400  00B9     MOVWF BlankStart
127:               BlankEnd = BlankEndStore; //blanking setting initialize
0401  30F0     MOVLW 0xF0
0402  318A     MOVLP 0xA
0403  22D3     CALL 0x2D3
0404  3183     MOVLP 0x3
0405  0140     MOVLB 0x0
0406  00DA     MOVWF value
0407  085A     MOVF value, W
0408  00B8     MOVWF BlankEnd
128:           
129:               //DS3232 startup check and initialization
130:               if (i2c_read1ByteRegister(ClockAddress, StatusReg) == 0b11001000) //checks status register matches the POR state (will true if this is the "first" time it has seen power)
0409  300F     MOVLW 0xF
040A  00DA     MOVWF value
040B  085A     MOVF value, W
040C  00D3     MOVWF reg
040D  3068     MOVLW 0x68
040E  3187     MOVLP 0x7
040F  2722     CALL 0x722
0410  3183     MOVLP 0x3
0411  3AC8     XORLW 0xC8
0412  1D03     BTFSS STATUS, 0x2
0413  2C5F     GOTO 0x45F
131:               {
132:                   i2c_write1ByteRegister(ClockAddress, StatusReg, 0b01001000); //this clears bit 7 in the status/control register, starting the oscillator.
0414  300F     MOVLW 0xF
0415  00DA     MOVWF value
0416  085A     MOVF value, W
0417  00D3     MOVWF reg
0418  3048     MOVLW 0x48
0419  00DB     MOVWF i2creg
041A  085B     MOVF i2creg, W
041B  00D4     MOVWF data
041C  3068     MOVLW 0x68
041D  318D     MOVLP 0xD
041E  25E3     CALL 0x5E3
041F  3183     MOVLP 0x3
133:                   i2c_write1ByteRegister(ClockAddress, MinutesReg, 0x30); //this and the next 4 lines set up a default date/time, which is the first time a D-mail is sent
0420  0140     MOVLB 0x0
0421  01D3     CLRF reg
0422  0AD3     INCF reg, F
0423  3030     MOVLW 0x30
0424  00DA     MOVWF value
0425  085A     MOVF value, W
0426  00D4     MOVWF data
0427  3068     MOVLW 0x68
0428  318D     MOVLP 0xD
0429  25E3     CALL 0x5E3
042A  3183     MOVLP 0x3
134:                   i2c_write1ByteRegister(ClockAddress, HoursReg, 0x12);
042B  3002     MOVLW 0x2
042C  0140     MOVLB 0x0
042D  00DA     MOVWF value
042E  085A     MOVF value, W
042F  00D3     MOVWF reg
0430  3012     MOVLW 0x12
0431  00DB     MOVWF i2creg
0432  085B     MOVF i2creg, W
0433  00D4     MOVWF data
0434  3068     MOVLW 0x68
0435  318D     MOVLP 0xD
0436  25E3     CALL 0x5E3
0437  3183     MOVLP 0x3
135:                   i2c_write1ByteRegister(ClockAddress, DateReg, 0x28);
0438  3004     MOVLW 0x4
0439  0140     MOVLB 0x0
043A  00DA     MOVWF value
043B  085A     MOVF value, W
043C  00D3     MOVWF reg
043D  3028     MOVLW 0x28
043E  00DB     MOVWF i2creg
043F  085B     MOVF i2creg, W
0440  00D4     MOVWF data
0441  3068     MOVLW 0x68
0442  318D     MOVLP 0xD
0443  25E3     CALL 0x5E3
0444  3183     MOVLP 0x3
136:                   i2c_write1ByteRegister(ClockAddress, MonthReg, 0x7);
0445  3005     MOVLW 0x5
0446  0140     MOVLB 0x0
0447  00DA     MOVWF value
0448  085A     MOVF value, W
0449  00D3     MOVWF reg
044A  3007     MOVLW 0x7
044B  00DB     MOVWF i2creg
044C  085B     MOVF i2creg, W
044D  00D4     MOVWF data
044E  3068     MOVLW 0x68
044F  318D     MOVLP 0xD
0450  25E3     CALL 0x5E3
0451  3183     MOVLP 0x3
137:                   i2c_write1ByteRegister(ClockAddress, YearReg, 0x10);
0452  3006     MOVLW 0x6
0453  0140     MOVLB 0x0
0454  00DA     MOVWF value
0455  085A     MOVF value, W
0456  00D3     MOVWF reg
0457  3010     MOVLW 0x10
0458  00DB     MOVWF i2creg
0459  085B     MOVF i2creg, W
045A  00D4     MOVWF data
045B  3068     MOVLW 0x68
045C  318D     MOVLP 0xD
045D  25E3     CALL 0x5E3
045E  3183     MOVLP 0x3
138:               }
139:               
140:               //Display Initialize
141:               EmptyTubes(); //blank the tubes
045F  318B     MOVLP 0xB
0460  238D     CALL 0x38D
0461  3183     MOVLP 0x3
142:               Loader(); //load the blank tubes to the display
0462  318E     MOVLP 0xE
0463  266F     CALL 0x66F
0464  3183     MOVLP 0x3
143:               TubesOn(); //turn the tubes on
0465  318D     MOVLP 0xD
0466  2567     CALL 0x567
144:               //END PROGRAM INITIALIZATION
145:               StartupDone = 1; //permanent bit to indicate that startup has been done 
0467  147C     BSF NegWL, 0x0
146:           }
0468  0008     RETURN
147:           
148:           void main(void) //Time Display
149:           {
150:               uint8_t newsec; //latest second read from the clock
151:               uint8_t oldsec; //the previous second read from the clock
152:               uint8_t spincount; //counter for the animation at 30s
153:               uint8_t shift; //slide shift counter
154:               
155:               if (!StartupDone) //check if we have done startup or not
0049  187C     BTFSC NegWL, 0x0
004A  284E     GOTO 0x4E
156:                   Startup(); //run the initialization
004B  3183     MOVLP 0x3
004C  23CA     CALL 0x3CA
004D  3180     MOVLP 0x0
157:               ei(); //start looking for interrupts, often turned off while in other areas of the program
004E  178B     BSF INTCON, 0x7
158:               while(1) //this all happens until an interrupt sends us places via flags
159:               {
160:                   if (GoDate == 1) //if the GoDate flag has been set
004F  1DFC     BTFSS NegWL, 0x3
0050  2855     GOTO 0x55
161:                       DateDisplay(); //display the date
0051  3185     MOVLP 0x5
0052  2508     CALL 0x508
0053  3180     MOVLP 0x0
0054  285A     GOTO 0x5A
162:                   else if (GoDM == 1) //if the GoDM flag has been set
0055  1D7C     BTFSS NegWL, 0x2
0056  285A     GOTO 0x5A
163:                       DMDisplay(); //go to the DM routines
0057  3181     MOVLP 0x1
0058  21B7     CALL 0x1B7
0059  3180     MOVLP 0x0
164:                   oldsec = newsec; //save the last read second for comparison
005A  0140     MOVLB 0x0
005B  086B     MOVF newsec, W
005C  00E6     MOVWF 0x66
005D  0866     MOVF 0x66, W
005E  00E8     MOVWF oldsec
165:                   newsec = i2c_read1ByteRegister(ClockAddress, SecondsReg); //get the next second, maybe
005F  01D3     CLRF reg
0060  3068     MOVLW 0x68
0061  3187     MOVLP 0x7
0062  2722     CALL 0x722
0063  3180     MOVLP 0x0
0064  00E6     MOVWF 0x66
0065  0866     MOVF 0x66, W
0066  00EB     MOVWF newsec
166:                   BCD2Bin(newsec); //convert to binary for display
0067  086B     MOVF newsec, W
0068  318B     MOVLP 0xB
0069  2369     CALL 0x369
006A  3180     MOVLP 0x0
167:                   if (newsec != oldsec) //is it actually a different second
006B  086B     MOVF newsec, W
006C  0668     XORWF oldsec, W
006D  1903     BTFSC STATUS, 0x2
006E  284F     GOTO 0x4F
168:                   {
169:                       SplitLoad(6); //load the seconds into the buffer
006F  3006     MOVLW 0x6
0070  318B     MOVLP 0xB
0071  237B     CALL 0x37B
0072  3180     MOVLP 0x0
170:                       if (newsec == 0x30) //if we are at a 30s
0073  3030     MOVLW 0x30
0074  066B     XORWF newsec, W
0075  1D03     BTFSS STATUS, 0x2
0076  28B4     GOTO 0xB4
171:                       {
172:                           DisplayBuf[0] = 0; //in case this was blanked in 12 hour mode
0077  01BF     CLRF DisplayBuf
173:                           DisplayBuf[2] = 0; //get the decimal point in
0078  01C1     CLRF 0x41
174:                           DisplayBuf[5] = 0; //this one as well
0079  01C4     CLRF 0x44
175:                           for (spincount=41; spincount--;) //do 40 animation cycles, no need to save the display since it will loop back to the same numbers
007A  3029     MOVLW 0x29
007B  00E6     MOVWF 0x66
007C  0866     MOVF 0x66, W
007D  00E9     MOVWF spincount
176:                           {
177:                               for (Pos=8; Pos--;) //tube loop
0084  3008     MOVLW 0x8
0085  00E6     MOVWF 0x66
0086  0866     MOVF 0x66, W
0087  00BE     MOVWF Pos
178:                               {
179:                                   DisplayBuf[Pos]++; //increment the displayed value
008D  3001     MOVLW 0x1
008E  00E6     MOVWF 0x66
008F  083E     MOVF Pos, W
0090  3E3F     ADDLW 0x3F
0091  0086     MOVWF FSR1
0092  0187     CLRF FSR1H
0093  0866     MOVF 0x66, W
0094  0781     ADDWF INDF1, F
180:                                   if (DisplayBuf[Pos] == 10) //if we get to 10
0095  083E     MOVF Pos, W
0096  3E3F     ADDLW 0x3F
0097  0086     MOVWF FSR1
0098  0187     CLRF FSR1H
0099  300A     MOVLW 0xA
009A  0601     XORWF INDF1, W
009B  1D03     BTFSS STATUS, 0x2
009C  2888     GOTO 0x88
181:                                       DisplayBuf[Pos] = 0; //wrap to 0
009D  083E     MOVF Pos, W
009E  3E3F     ADDLW 0x3F
009F  0086     MOVWF FSR1
00A0  0187     CLRF FSR1H
00A1  0181     CLRF INDF1
182:                               }
0088  3001     MOVLW 0x1
0089  02BE     SUBWF Pos, F
008A  0A3E     INCF Pos, W
008B  1903     BTFSC STATUS, 0x2
008C  28A3     GOTO 0xA3
00A2  2888     GOTO 0x88
183:                               Loader(); //once all the tubes are done
00A3  318E     MOVLP 0xE
00A4  266F     CALL 0x66F
00A5  3180     MOVLP 0x0
184:                               _delay(debounce); //tube display time
00A6  3015     MOVLW 0x15
00A7  0140     MOVLB 0x0
00A8  00E6     MOVWF 0x66
00A9  30C6     MOVLW 0xC6
00AA  0B89     DECFSZ WREG, F
00AB  28AA     GOTO 0xAA
00AC  0BE6     DECFSZ 0x66, F
00AD  28AA     GOTO 0xAA
00AE  0000     NOP
185:                           }
007E  3001     MOVLW 0x1
007F  0140     MOVLB 0x0
0080  02E9     SUBWF spincount, F
0081  0A69     INCF spincount, W
0082  1903     BTFSC STATUS, 0x2
0083  28B0     GOTO 0xB0
00AF  287E     GOTO 0x7E
186:                           DateDisplay(); //display the date for a bit once the animation is done
00B0  3185     MOVLP 0x5
00B1  2508     CALL 0x508
00B2  3180     MOVLP 0x0
187:                       }
00B3  2920     GOTO 0x120
188:                       else if (newsec == 0x59) //if we are near the top of a minute
00B4  3059     MOVLW 0x59
00B5  066B     XORWF newsec, W
00B6  1D03     BTFSS STATUS, 0x2
00B7  2920     GOTO 0x120
189:                       {
190:                           DisplayBufSave(); //make a backup of the display
00B8  318B     MOVLP 0xB
00B9  23C7     CALL 0x3C7
00BA  3180     MOVLP 0x0
191:                           for (shift=8; shift--;) //shift the display out the left side
00BB  3008     MOVLW 0x8
00BC  00E6     MOVWF 0x66
00BD  0866     MOVF 0x66, W
00BE  00EA     MOVWF shift
192:                           {
193:                               for (Pos=0; Pos<8; Pos++) //shift through the tubes
00C5  01BE     CLRF Pos
00C6  3008     MOVLW 0x8
00C7  023E     SUBWF Pos, W
00C8  1803     BTFSC STATUS, 0x0
00C9  28DB     GOTO 0xDB
194:                               { //no fancy c compiler tricks for space saving, only works one way around        
195:                                   DisplayBuf[Pos] = DisplayBuf[Pos + 1]; //make the tube = the next one
00CA  083E     MOVF Pos, W
00CB  3E40     ADDLW 0x40
00CC  0086     MOVWF FSR1
00CD  0187     CLRF FSR1H
00CE  0801     MOVF INDF1, W
00CF  00E6     MOVWF 0x66
00D0  083E     MOVF Pos, W
00D1  3E3F     ADDLW 0x3F
00D2  0086     MOVWF FSR1
00D3  0187     CLRF FSR1H
00D4  0866     MOVF 0x66, W
00D5  0081     MOVWF INDF1
196:                               }
00D6  3001     MOVLW 0x1
00D7  00E6     MOVWF 0x66
00D8  0866     MOVF 0x66, W
00D9  07BE     ADDWF Pos, F
00DA  28C6     GOTO 0xC6
197:                               DisplayBuf[7] = 10; //except for the last one, it back fills the display with blanks
00DB  300A     MOVLW 0xA
00DC  00E6     MOVWF 0x66
00DD  0866     MOVF 0x66, W
00DE  00C6     MOVWF 0x46
198:                               Loader(); //display this round
00DF  318E     MOVLP 0xE
00E0  266F     CALL 0x66F
00E1  3180     MOVLP 0x0
199:                               _delay(40000); //time for display
00E2  3034     MOVLW 0x34
00E3  0140     MOVLB 0x0
00E4  00E6     MOVWF 0x66
00E5  30F1     MOVLW 0xF1
00E6  0B89     DECFSZ WREG, F
00E7  28E6     GOTO 0xE6
00E8  0BE6     DECFSZ 0x66, F
00E9  28E6     GOTO 0xE6
00EA  3200     BRA 0xEB
200:                           } //ok, the display is now blank
00BF  3001     MOVLW 0x1
00C0  0140     MOVLB 0x0
00C1  02EA     SUBWF shift, F
00C2  0A6A     INCF shift, W
00C3  1903     BTFSC STATUS, 0x2
00C4  28EC     GOTO 0xEC
00EB  28BF     GOTO 0xBF
201:                           for (shift=8; shift--;) //now we shift the blank tubes out and shift in the saved values
00EC  3008     MOVLW 0x8
00ED  00E6     MOVWF 0x66
00EE  0866     MOVF 0x66, W
00EF  00EA     MOVWF shift
202:                           {
203:                               DisplayBuf[7] = DisplaySave[shift]; //get saved value and put it in the right most tube
00F5  086A     MOVF shift, W
00F6  3EBD     ADDLW 0xBD
00F7  0086     MOVWF FSR1
00F8  0187     CLRF FSR1H
00F9  0801     MOVF INDF1, W
00FA  00E6     MOVWF 0x66
00FB  0866     MOVF 0x66, W
00FC  00C6     MOVWF 0x46
204:                               Loader(); //display this
00FD  318E     MOVLP 0xE
00FE  266F     CALL 0x66F
00FF  3180     MOVLP 0x0
205:                               _delay(40000); //time for display
0100  3034     MOVLW 0x34
0101  0140     MOVLB 0x0
0102  00E6     MOVWF 0x66
0103  30F1     MOVLW 0xF1
0104  0B89     DECFSZ WREG, F
0105  2904     GOTO 0x104
0106  0BE6     DECFSZ 0x66, F
0107  2904     GOTO 0x104
0108  3200     BRA 0x109
206:                               for (Pos=0; Pos<8; Pos++) //shift though the tubes
0109  0140     MOVLB 0x0
010A  01BE     CLRF Pos
010B  3008     MOVLW 0x8
010C  023E     SUBWF Pos, W
010D  1803     BTFSC STATUS, 0x0
010E  28F0     GOTO 0xF0
207:                               { //no fancy c compiler tricks for space saving, only works one way around
208:                                   DisplayBuf[Pos] = DisplayBuf[Pos + 1]; //make the tube = the next one, in preparation for the next value to be added
010F  083E     MOVF Pos, W
0110  3E40     ADDLW 0x40
0111  0086     MOVWF FSR1
0112  0187     CLRF FSR1H
0113  0801     MOVF INDF1, W
0114  00E6     MOVWF 0x66
0115  083E     MOVF Pos, W
0116  3E3F     ADDLW 0x3F
0117  0086     MOVWF FSR1
0118  0187     CLRF FSR1H
0119  0866     MOVF 0x66, W
011A  0081     MOVWF INDF1
209:                               }
011B  3001     MOVLW 0x1
011C  00E6     MOVWF 0x66
011D  0866     MOVF 0x66, W
011E  07BE     ADDWF Pos, F
011F  290B     GOTO 0x10B
210:                           }
00F0  3001     MOVLW 0x1
00F1  02EA     SUBWF shift, F
00F2  0A6A     INCF shift, W
00F3  1903     BTFSC STATUS, 0x2
00F4  2920     GOTO 0x120
211:                       }
212:                       BCD2Bin(i2c_read1ByteRegister(ClockAddress, MinutesReg)); //get the minutes
0120  01D3     CLRF reg
0121  0AD3     INCF reg, F
0122  3068     MOVLW 0x68
0123  3187     MOVLP 0x7
0124  2722     CALL 0x722
0125  3180     MOVLP 0x0
0126  318B     MOVLP 0xB
0127  2369     CALL 0x369
0128  3180     MOVLP 0x0
213:                       SplitLoad(3); //load the minutes into the buffer
0129  3003     MOVLW 0x3
012A  318B     MOVLP 0xB
012B  237B     CALL 0x37B
012C  3180     MOVLP 0x0
214:                       Temp = i2c_read1ByteRegister(ClockAddress, HoursReg); //get the hour, in a variable for later checks
012D  3002     MOVLW 0x2
012E  00E6     MOVWF 0x66
012F  0866     MOVF 0x66, W
0130  00D3     MOVWF reg
0131  3068     MOVLW 0x68
0132  3187     MOVLP 0x7
0133  2722     CALL 0x722
0134  3180     MOVLP 0x0
0135  00E7     MOVWF 0x67
0136  0867     MOVF 0x67, W
0137  00B7     MOVWF Temp
215:                       BCD2Bin(Temp); //load the hours into the buffer
0138  0837     MOVF Temp, W
0139  318B     MOVLP 0xB
013A  2369     CALL 0x369
013B  3180     MOVLP 0x0
216:                       if (Temp == BlankStart) //are we at the start of the blank time?
013C  0837     MOVF Temp, W
013D  0639     XORWF BlankStart, W
013E  1D03     BTFSS STATUS, 0x2
013F  2944     GOTO 0x144
217:                           TubesOff(); //if so, turn off the display
0140  318A     MOVLP 0xA
0141  2227     CALL 0x227
0142  3180     MOVLP 0x0
0143  294B     GOTO 0x14B
218:                       else if (Temp == BlankEnd) //are we at the end of the blank time?
0144  0837     MOVF Temp, W
0145  0638     XORWF BlankEnd, W
0146  1D03     BTFSS STATUS, 0x2
0147  294B     GOTO 0x14B
219:                           TubesOn(); //if so, turn on the display
0148  318D     MOVLP 0xD
0149  2567     CALL 0x567
014A  3180     MOVLP 0x0
220:                       SplitLoad(0); //load the hours into the buffer
014B  3000     MOVLW 0x0
014C  318B     MOVLP 0xB
014D  237B     CALL 0x37B
014E  3180     MOVLP 0x0
221:                       if (HourType == 1) //12 hour mode?
014F  033A     DECF HourType, W
0150  1D03     BTFSS STATUS, 0x2
0151  2961     GOTO 0x161
222:                       {
223:                           if (Temp > 0x12) //is the current hour 13+?
0152  3013     MOVLW 0x13
0153  0237     SUBWF Temp, W
0154  1C03     BTFSS STATUS, 0x0
0155  295A     GOTO 0x15A
224:                           {
225:                               DisplayBuf[0] -= 1; //subtract 12 if so
0156  3001     MOVLW 0x1
0157  02BF     SUBWF DisplayBuf, F
226:                               DisplayBuf[1] -= 2;
0158  3002     MOVLW 0x2
0159  02C0     SUBWF 0x40, F
227:                           }
228:                           if (DisplayBuf[0] == 0) //is the hour below 10?
015A  083F     MOVF DisplayBuf, W
015B  1D03     BTFSS STATUS, 0x2
015C  2961     GOTO 0x161
229:                           {
230:                               DisplayBuf[0] = 10; //since we are less than 10, the first tube does not need a digit 
015D  300A     MOVLW 0xA
015E  00E6     MOVWF 0x66
015F  0866     MOVF 0x66, W
0160  00BF     MOVWF DisplayBuf
231:                           }
232:                       }
233:                       DisplayBuf[2] = R; //right DPs
0161  3052     MOVLW 0x52
0162  00E6     MOVWF 0x66
0163  0866     MOVF 0x66, W
0164  00C1     MOVWF 0x41
234:                       DisplayBuf[5] = R;
0165  3052     MOVLW 0x52
0166  00E6     MOVWF 0x66
0167  0866     MOVF 0x66, W
0168  00C4     MOVWF 0x44
235:                       if (DisplayBuf[7] & 1) //if seconds are even, swap to left DP
0169  1C46     BTFSS 0x46, 0x0
016A  2973     GOTO 0x173
236:                       {
237:                           DisplayBuf[2] = L; //left DPs
016B  304C     MOVLW 0x4C
016C  00E6     MOVWF 0x66
016D  0866     MOVF 0x66, W
016E  00C1     MOVWF 0x41
238:                           DisplayBuf[5] = L;
016F  304C     MOVLW 0x4C
0170  00E6     MOVWF 0x66
0171  0866     MOVF 0x66, W
0172  00C4     MOVWF 0x44
239:                       }
240:                       if (TimeAdj != 0) //if there is a time adjust setting
0173  082A     MOVF TimeAdj, W
0174  042B     IORWF 0x2B, W
0175  1903     BTFSC STATUS, 0x2
0176  299E     GOTO 0x19E
241:                       {
242:                           TimeAdj--; //decrement, this is basically a counter
0177  3001     MOVLW 0x1
0178  02AA     SUBWF TimeAdj, F
0179  3000     MOVLW 0x0
017A  3BAB     SUBWFB 0x2B, F
243:                           if (TimeAdj == 0) //if we are now at 0
017B  082A     MOVF TimeAdj, W
017C  042B     IORWF 0x2B, W
017D  1D03     BTFSS STATUS, 0x2
017E  299E     GOTO 0x19E
244:                           {
245:                               while(i2c_read1ByteRegister(ClockAddress, SecondsReg) != 0b00000001){} //wait until we get a 1 in the seconds register
017F  01D3     CLRF reg
0180  3068     MOVLW 0x68
0181  3187     MOVLP 0x7
0182  2722     CALL 0x722
0183  3180     MOVLP 0x0
0184  3A01     XORLW 0x1
0185  1D03     BTFSS STATUS, 0x2
0186  297F     GOTO 0x17F
246:                               if (TimeFast == 1) //if we are set up for moving backward
0187  033D     DECF TimeFast, W
0188  1D03     BTFSS STATUS, 0x2
0189  298D     GOTO 0x18D
247:                                   i2c_write1ByteRegister(ClockAddress, SecondsReg, 0b00000000); //take that 1 and make it a 0
018A  01D3     CLRF reg
018B  01D4     CLRF data
018C  2992     GOTO 0x192
248:                               else //if we are setup for moving forward
249:                                   i2c_write1ByteRegister(ClockAddress, SecondsReg, 0b00000010); //take that 1 and make it a 2
018D  01D3     CLRF reg
018E  3002     MOVLW 0x2
018F  00E6     MOVWF 0x66
0190  0866     MOVF 0x66, W
0191  00D4     MOVWF data
0192  3068     MOVLW 0x68
0193  318D     MOVLP 0xD
0194  25E3     CALL 0x5E3
0195  3180     MOVLP 0x0
250:                               TimeAdj = TimeAdjStore; //reset the counter from the stored setting
0196  30F5     MOVLW 0xF5
0197  318B     MOVLP 0xB
0198  23A0     CALL 0x3A0
0199  3180     MOVLP 0x0
019A  0877     MOVF divisor, W
019B  00AB     MOVWF 0x2B
019C  0876     MOVF cb, W
019D  00AA     MOVWF TimeAdj
251:                           }
252:                       }
253:                       if ((DisplayBuf[3]|DisplayBuf[4]|DisplayBuf[6]|DisplayBuf[7]) == 0) //all these positions must be 0 to be true
019E  0842     MOVF 0x42, W
019F  0443     IORWF 0x43, W
01A0  0445     IORWF 0x45, W
01A1  0446     IORWF 0x46, W
01A2  1D03     BTFSS STATUS, 0x2
01A3  29AA     GOTO 0x1AA
254:                       {
255:                           DisplayBufSave(); //save the display
01A4  318B     MOVLP 0xB
01A5  23C7     CALL 0x3C7
01A6  3180     MOVLP 0x0
256:                           FixedWL(); //run a fixed animation
01A7  318C     MOVLP 0xC
01A8  24C2     CALL 0x4C2
01A9  3180     MOVLP 0x0
257:                       }
258:                       Loader(); //load it all to the tubes
01AA  318E     MOVLP 0xE
01AB  266F     CALL 0x66F
01AC  3180     MOVLP 0x0
259:                       _delay(debounce); //display time
01AD  3015     MOVLW 0x15
01AE  0140     MOVLB 0x0
01AF  00E6     MOVWF 0x66
01B0  30C6     MOVLW 0xC6
01B1  0B89     DECFSZ WREG, F
01B2  29B1     GOTO 0x1B1
01B3  0BE6     DECFSZ 0x66, F
01B4  29B1     GOTO 0x1B1
01B5  0000     NOP
260:                   }
261:               }
262:           }
263:           
264:           void DateDisplay(void)
265:           {
266:               GoDate = 0; //clear the flag in case we got here via that
0508  11FC     BCF NegWL, 0x3
267:               //INTERRUPT_GlobalInterruptDisable(); //turn off interrupts, buttons are used for other things here
268:               BCD2Bin(i2c_read1ByteRegister(ClockAddress, DateReg)); //get the date
0509  3004     MOVLW 0x4
050A  0140     MOVLB 0x0
050B  00E5     MOVWF 0x65
050C  0865     MOVF 0x65, W
050D  00D3     MOVWF reg
050E  3068     MOVLW 0x68
050F  3187     MOVLP 0x7
0510  2722     CALL 0x722
0511  3185     MOVLP 0x5
0512  318B     MOVLP 0xB
0513  2369     CALL 0x369
0514  3185     MOVLP 0x5
269:               SplitLoad(3); //load the date into the buffer
0515  3003     MOVLW 0x3
0516  318B     MOVLP 0xB
0517  237B     CALL 0x37B
0518  3185     MOVLP 0x5
270:               BCD2Bin(i2c_read1ByteRegister(ClockAddress, MonthReg)); //get the month
0519  3005     MOVLW 0x5
051A  00E5     MOVWF 0x65
051B  0865     MOVF 0x65, W
051C  00D3     MOVWF reg
051D  3068     MOVLW 0x68
051E  3187     MOVLP 0x7
051F  2722     CALL 0x722
0520  3185     MOVLP 0x5
0521  318B     MOVLP 0xB
0522  2369     CALL 0x369
0523  3185     MOVLP 0x5
271:               SplitLoad(0); //load the month into the buffer
0524  3000     MOVLW 0x0
0525  318B     MOVLP 0xB
0526  237B     CALL 0x37B
0527  3185     MOVLP 0x5
272:               BCD2Bin(i2c_read1ByteRegister(ClockAddress, YearReg)); //get the year
0528  3006     MOVLW 0x6
0529  00E5     MOVWF 0x65
052A  0865     MOVF 0x65, W
052B  00D3     MOVWF reg
052C  3068     MOVLW 0x68
052D  3187     MOVLP 0x7
052E  2722     CALL 0x722
052F  3185     MOVLP 0x5
0530  318B     MOVLP 0xB
0531  2369     CALL 0x369
0532  3185     MOVLP 0x5
273:               SplitLoad(6); //load the year into the buffer
0533  3006     MOVLW 0x6
0534  318B     MOVLP 0xB
0535  237B     CALL 0x37B
0536  3185     MOVLP 0x5
274:               DisplayBuf[2] = 10; //blank separating tubes
0537  300A     MOVLW 0xA
0538  00E5     MOVWF 0x65
0539  0865     MOVF 0x65, W
053A  00C1     MOVWF 0x41
275:               DisplayBuf[5] = 10;
053B  300A     MOVLW 0xA
053C  00E5     MOVWF 0x65
053D  0865     MOVF 0x65, W
053E  00C4     MOVWF 0x44
276:               if (DateFormat == 1) //if DDMMYY is preferred 
053F  033C     DECF DateFormat, W
0540  1D03     BTFSS STATUS, 0x2
0541  2D5A     GOTO 0x55A
277:               {
278:                   Temp = DisplayBuf[0]; //quick save of the month
0542  083F     MOVF DisplayBuf, W
0543  00E5     MOVWF 0x65
0544  0865     MOVF 0x65, W
0545  00B7     MOVWF Temp
279:                   Pos = DisplayBuf[1]; //borrowing this here to save memory
0546  0840     MOVF 0x40, W
0547  00E5     MOVWF 0x65
0548  0865     MOVF 0x65, W
0549  00BE     MOVWF Pos
280:                   DisplayBuf[0] = DisplayBuf[3]; //flip the month 10s over
054A  0842     MOVF 0x42, W
054B  00E5     MOVWF 0x65
054C  0865     MOVF 0x65, W
054D  00BF     MOVWF DisplayBuf
281:                   DisplayBuf[1] = DisplayBuf[4]; //flip the month 1s over
054E  0843     MOVF 0x43, W
054F  00E5     MOVWF 0x65
0550  0865     MOVF 0x65, W
0551  00C0     MOVWF 0x40
282:                   DisplayBuf[3] = Temp; //flip the day 10s over
0552  0837     MOVF Temp, W
0553  00E5     MOVWF 0x65
0554  0865     MOVF 0x65, W
0555  00C2     MOVWF 0x42
283:                   DisplayBuf[4] = Pos; //flip the day 1s over
0556  083E     MOVF Pos, W
0557  00E5     MOVWF 0x65
0558  0865     MOVF 0x65, W
0559  00C3     MOVWF 0x43
284:               }
285:               while (SW2_GetValue()){} //wait for SW2 to be released
055A  188E     BTFSC PORTC, 0x1
055B  2D5A     GOTO 0x55A
286:               Loader(); //display the date
055C  318E     MOVLP 0xE
055D  266F     CALL 0x66F
055E  3185     MOVLP 0x5
287:               _delay(debounce); //give the tubes a second to display
055F  3015     MOVLW 0x15
0560  0140     MOVLB 0x0
0561  00E5     MOVWF 0x65
0562  30C6     MOVLW 0xC6
0563  0B89     DECFSZ WREG, F
0564  2D63     GOTO 0x563
0565  0BE5     DECFSZ 0x65, F
0566  2D63     GOTO 0x563
0567  0000     NOP
288:               for (Pos=121; Pos--;) //loop here, showing the date, for about 3 seconds 
0568  3079     MOVLW 0x79
0569  0140     MOVLB 0x0
056A  00E5     MOVWF 0x65
056B  0865     MOVF 0x65, W
056C  00BE     MOVWF Pos
289:               {
290:                   if (SW2_GetValue()) //check if SW2 got pressed again
0573  1C8E     BTFSS PORTC, 0x1
0574  2D78     GOTO 0x578
291:                       Settings(); //go to the settings
0575  3182     MOVLP 0x2
0576  2273     CALL 0x273
0577  3185     MOVLP 0x5
292:                   _delay(debounce); //small delay
0578  3015     MOVLW 0x15
0579  0140     MOVLB 0x0
057A  00E5     MOVWF 0x65
057B  30C6     MOVLW 0xC6
057C  0B89     DECFSZ WREG, F
057D  2D7C     GOTO 0x57C
057E  0BE5     DECFSZ 0x65, F
057F  2D7C     GOTO 0x57C
0580  0000     NOP
293:               }
056D  3001     MOVLW 0x1
056E  0140     MOVLB 0x0
056F  02BE     SUBWF Pos, F
0570  0A3E     INCF Pos, W
0571  1903     BTFSC STATUS, 0x2
0572  0008     RETURN
0581  2D6D     GOTO 0x56D
294:               return; //back to the time
295:           }
296:           
297:           void DMDisplay(void)
298:           {
299:               uint8_t seedadr = 0x77; //starting EEPROM address for loading saved values 
300:               
301:               //INTERRUPT_GlobalInterruptDisable(); //turn off interrupts, buttons are used for other things here
302:               GoDM = 0; //clear flag if we got here by interrupt
01B7  117C     BCF NegWL, 0x2
303:               EEPROMBufferFill(seedadr);
01B8  3077     MOVLW 0x77
01B9  318C     MOVLP 0xC
01BA  2453     CALL 0x453
01BB  3181     MOVLP 0x1
304:               Loader(); //show the WL
01BC  318E     MOVLP 0xE
01BD  266F     CALL 0x66F
01BE  3181     MOVLP 0x1
305:               seedadr = 0x07; //move the starting point to the "first" number of the next WL
01BF  3007     MOVLW 0x7
01C0  00DE     MOVWF max
01C1  085E     MOVF max, W
01C2  00DF     MOVWF seedadr
306:               while (1) //main loop, i am not happy with this double while loop thing, may implement 4th button press type to avoid this
307:               {
308:                   Temp = Buttons(); //get a button press
01C7  318E     MOVLP 0xE
01C8  26D5     CALL 0x6D5
01C9  3181     MOVLP 0x1
01CA  00DE     MOVWF max
01CB  085E     MOVF max, W
01CC  00B7     MOVWF Temp
309:                   if (Temp == 1) //if short SW1
01C3  29C7     GOTO 0x1C7
01CD  0337     DECF Temp, W
01CE  1903     BTFSC STATUS, 0x2
01CF  29C4     GOTO 0x1C4
310:                       RandomWL(); //do a random number
01C4  3187     MOVLP 0x7
01C5  27AD     CALL 0x7AD
01C6  3181     MOVLP 0x1
311:                   else if (Temp == 2) //if long SW1
01D0  3002     MOVLW 0x2
01D1  0637     XORWF Temp, W
01D2  1D03     BTFSS STATUS, 0x2
01D3  0008     RETURN
312:                   {
313:                       while (1) //sub loop
314:                       {
315:                           if (seedadr == 0x7F) //this is the address that will be present after the last WL
01D4  307F     MOVLW 0x7F
01D5  065F     XORWF seedadr, W
01D6  1903     BTFSC STATUS, 0x2
01D7  29C7     GOTO 0x1C7
316:                               break; //leave sub loop
317:                           EEPROMBufferFill(seedadr);
01D8  085F     MOVF seedadr, W
01D9  318C     MOVLP 0xC
01DA  2453     CALL 0x453
01DB  3181     MOVLP 0x1
318:                           DisplayBufSave(); //backup the display buffer
01DC  318B     MOVLP 0xB
01DD  23C7     CALL 0x3C7
01DE  3181     MOVLP 0x1
319:                           FixedWL(); //animation returning to original state
01DF  318C     MOVLP 0xC
01E0  24C2     CALL 0x4C2
01E1  3181     MOVLP 0x1
320:                           seedadr += 8; //move the starting point to the "first" number of the next WL
01E2  3008     MOVLW 0x8
01E3  00DE     MOVWF max
01E4  085E     MOVF max, W
01E5  07DF     ADDWF seedadr, F
321:                           Temp = Buttons(); //get another button press
01E6  318E     MOVLP 0xE
01E7  26D5     CALL 0x6D5
01E8  3181     MOVLP 0x1
01E9  00DE     MOVWF max
01EA  085E     MOVF max, W
01EB  00B7     MOVWF Temp
322:                           if (Temp == 1) //if short SW1
01EC  0337     DECF Temp, W
01ED  1903     BTFSC STATUS, 0x2
01EE  29D4     GOTO 0x1D4
323:                               continue; //go around again for the next WL
324:                           else if (Temp == 2) //if long SW1
01EF  3002     MOVLW 0x2
01F0  0637     XORWF Temp, W
01F1  1903     BTFSC STATUS, 0x2
01F2  0008     RETURN
325:                               return; //go to clock
326:                           else //if SW2, user defined WL
327:                           {
328:                               EmptyTubes(); //clear tube buffer in preparation for setting the WL
01F3  318B     MOVLP 0xB
01F4  238D     CALL 0x38D
01F5  3181     MOVLP 0x1
329:                               DisplayBuf[1] = R; //set the DP
01F6  3052     MOVLW 0x52
01F7  00DE     MOVWF max
01F8  085E     MOVF max, W
01F9  00C0     MOVWF 0x40
330:                               for (Pos=0; Pos<8; Pos++) //start setting the tubes, cant do loop code saving for usability
01FA  01BE     CLRF Pos
01FB  3008     MOVLW 0x8
01FC  023E     SUBWF Pos, W
01FD  1803     BTFSC STATUS, 0x0
01FE  2A43     GOTO 0x243
331:                               {
332:                                   if (Pos == 1) //skip the DP tube
01FF  033E     DECF Pos, W
0200  1903     BTFSC STATUS, 0x2
0201  2A3E     GOTO 0x23E
0202  2A2E     GOTO 0x22E
333:                                       continue; //and go to the next tube
334:                                   while (1) //loop this bit
335:                                   {
336:                                       Loader(); //load values so far
022E  318E     MOVLP 0xE
022F  266F     CALL 0x66F
0230  3181     MOVLP 0x1
337:                                       Temp = Buttons(); //get a button press
0231  318E     MOVLP 0xE
0232  26D5     CALL 0x6D5
0233  3181     MOVLP 0x1
0234  00DE     MOVWF max
0235  085E     MOVF max, W
0236  00B7     MOVWF Temp
338:                                       if (Temp == 1) //if short SW1
0237  0337     DECF Temp, W
0238  1903     BTFSC STATUS, 0x2
0239  2A03     GOTO 0x203
339:                                       {
340:                                           DisplayBuf[Pos]++; //increment number
0203  3001     MOVLW 0x1
0204  00DE     MOVWF max
0205  083E     MOVF Pos, W
0206  3E3F     ADDLW 0x3F
0207  0086     MOVWF FSR1
0208  0187     CLRF FSR1H
0209  085E     MOVF max, W
020A  0781     ADDWF INDF1, F
341:                                           if (DisplayBuf[Pos] == 11) //if we pass 10
020B  083E     MOVF Pos, W
020C  3E3F     ADDLW 0x3F
020D  0086     MOVWF FSR1
020E  0187     CLRF FSR1H
020F  300B     MOVLW 0xB
0210  0601     XORWF INDF1, W
0211  1D03     BTFSS STATUS, 0x2
0212  2A2E     GOTO 0x22E
342:                                               DisplayBuf[Pos] = 0; //wrap to 0
0213  083E     MOVF Pos, W
0214  3E3F     ADDLW 0x3F
0215  0086     MOVWF FSR1
0216  0187     CLRF FSR1H
0217  0181     CLRF INDF1
0218  2A2E     GOTO 0x22E
343:                                       }
344:                                       else if (Temp == 2) //if long SW1
023A  3002     MOVLW 0x2
023B  0637     XORWF Temp, W
023C  1903     BTFSC STATUS, 0x2
023D  2A19     GOTO 0x219
345:                                       {
346:                                           DisplayBuf[Pos]--; //decrement number
0219  083E     MOVF Pos, W
021A  3E3F     ADDLW 0x3F
021B  0086     MOVWF FSR1
021C  0187     CLRF FSR1H
021D  3001     MOVLW 0x1
021E  0281     SUBWF INDF1, F
347:                                           if (DisplayBuf[Pos] == 255) //if we pass 0
021F  083E     MOVF Pos, W
0220  3E3F     ADDLW 0x3F
0221  0086     MOVWF FSR1
0222  0187     CLRF FSR1H
0223  0A01     INCF INDF1, W
0224  1D03     BTFSS STATUS, 0x2
0225  2A2E     GOTO 0x22E
348:                                               DisplayBuf[Pos] = 10; //wrap to 10
0226  300A     MOVLW 0xA
0227  00DE     MOVWF max
0228  083E     MOVF Pos, W
0229  3E3F     ADDLW 0x3F
022A  0086     MOVWF FSR1
022B  0187     CLRF FSR1H
022C  085E     MOVF max, W
022D  0081     MOVWF INDF1
349:                                       }
350:                                       else //if SW2
351:                                           break; //next tube
352:                                   }
353:                               }
023E  3001     MOVLW 0x1
023F  00DE     MOVWF max
0240  085E     MOVF max, W
0241  07BE     ADDWF Pos, F
0242  29FB     GOTO 0x1FB
354:                               for (Pos=9; Pos--;) //this will blink the tubes 4 times (4 on 4 off)
0243  3009     MOVLW 0x9
0244  00DE     MOVWF max
0245  085E     MOVF max, W
0246  00BE     MOVWF Pos
355:                               {
356:                                   BL_Toggle(); //flip the blanking bit
024D  3010     MOVLW 0x10
024E  00DE     MOVWF max
024F  085E     MOVF max, W
0250  069A     XORWF LATC, F
357:                                   _delay(28000); //delay for a bit
0251  3025     MOVLW 0x25
0252  0140     MOVLB 0x0
0253  00DE     MOVWF max
0254  305B     MOVLW 0x5B
0255  0B89     DECFSZ WREG, F
0256  2A55     GOTO 0x255
0257  0BDE     DECFSZ max, F
0258  2A55     GOTO 0x255
0259  3200     BRA 0x25A
358:                               }
0247  3001     MOVLW 0x1
0248  0140     MOVLB 0x0
0249  02BE     SUBWF Pos, F
024A  0A3E     INCF Pos, W
024B  1903     BTFSC STATUS, 0x2
024C  2A5B     GOTO 0x25B
025A  2A47     GOTO 0x247
359:                               DisplayBufSave(); //save the user set number here
025B  318B     MOVLP 0xB
025C  23C7     CALL 0x3C7
025D  3181     MOVLP 0x1
360:                               while (1) //loop this last part
361:                               {
362:                                   Temp = Buttons(); //get a button return
025E  318E     MOVLP 0xE
025F  26D5     CALL 0x6D5
0260  3181     MOVLP 0x1
0261  00DE     MOVWF max
0262  085E     MOVF max, W
0263  00B7     MOVWF Temp
363:                                   if (Temp == 1) //if short SW1
0264  0337     DECF Temp, W
0265  1D03     BTFSS STATUS, 0x2
0266  0008     RETURN
364:                                   {
365:                                       if (Toggle == 1) //if we are on an even loop
0267  1CFC     BTFSS NegWL, 0x1
0268  2A6D     GOTO 0x26D
366:                                           FixedWL(); //do the fixed animation
0269  318C     MOVLP 0xC
026A  24C2     CALL 0x4C2
026B  3181     MOVLP 0x1
026C  2A70     GOTO 0x270
367:                                       else //if on the odd loop
368:                                           RandomWL(); //random WL and animation
026D  3187     MOVLP 0x7
026E  27AD     CALL 0x7AD
026F  3181     MOVLP 0x1
369:                                       Toggle ^= 1; //flip the toggle bit
0270  3002     MOVLW 0x2
0271  06FC     XORWF NegWL, F
370:                                   }
0272  2A5E     GOTO 0x25E
371:                                   else //if anything else
372:                                       return; //go back to the time
373:                               }
374:                           }
375:                       }
376:                   }
377:                   else //we get here if a 3 (SW2) was returned
378:                       return; //back to the time
379:               }
380:           }
381:           
382:           void Settings(void)
383:           {
384:               //INTERRUPT_GlobalInterruptDisable(); //turn off interrupts, buttons are used for other things here
385:               EmptyTubes(); //clear tubes
0273  318B     MOVLP 0xB
0274  238D     CALL 0x38D
0275  3182     MOVLP 0x2
386:               DisplayBuf[4] = 1; //load the version number
0276  01C3     CLRF 0x43
0277  0AC3     INCF 0x43, F
387:               DisplayBuf[5] = L;
0278  304C     MOVLW 0x4C
0279  00E2     MOVWF 0x62
027A  0862     MOVF 0x62, W
027B  00C4     MOVWF 0x44
388:               DisplayBuf[6] = 0;
027C  01C5     CLRF 0x45
389:               DisplayBuf[7] = 0;
027D  01C6     CLRF 0x46
390:               Loader(); //display the version number
027E  318E     MOVLP 0xE
027F  266F     CALL 0x66F
0280  3182     MOVLP 0x2
391:               while (SW2_GetValue()){} //wait for SW2 release
0281  188E     BTFSC PORTC, 0x1
0282  2A81     GOTO 0x281
392:               _delay(debounce); //debounce the tubes/button
0283  3015     MOVLW 0x15
0284  0140     MOVLB 0x0
0285  00E2     MOVWF 0x62
0286  30C6     MOVLW 0xC6
0287  0B89     DECFSZ WREG, F
0288  2A87     GOTO 0x287
0289  0BE2     DECFSZ 0x62, F
028A  2A87     GOTO 0x287
028B  0000     NOP
393:               EmptyTubes(); //empty the tubes
028C  318B     MOVLP 0xB
028D  238D     CALL 0x38D
028E  3182     MOVLP 0x2
394:               DisplayBuf[0] = 0; //setting #1
028F  01BF     CLRF DisplayBuf
395:               DisplayBuf[1] = 1;
0290  01C0     CLRF 0x40
0291  0AC0     INCF 0x40, F
396:               BCDSetInc(0x23, 0, HoursReg); //do the hour setting
0292  01DA     CLRF value
0293  3002     MOVLW 0x2
0294  00E2     MOVWF 0x62
0295  0862     MOVF 0x62, W
0296  00DB     MOVWF i2creg
0297  3023     MOVLW 0x23
0298  3184     MOVLP 0x4
0299  2469     CALL 0x469
029A  3182     MOVLP 0x2
397:               DisplayBuf[1]++; //setting #2
029B  3001     MOVLW 0x1
029C  0140     MOVLB 0x0
029D  00E2     MOVWF 0x62
029E  0862     MOVF 0x62, W
029F  07C0     ADDWF 0x40, F
398:               BCDSetInc(0x59, 0, MinutesReg); //do the minute setting
02A0  01DA     CLRF value
02A1  01DB     CLRF i2creg
02A2  0ADB     INCF i2creg, F
02A3  3059     MOVLW 0x59
02A4  3184     MOVLP 0x4
02A5  2469     CALL 0x469
02A6  3182     MOVLP 0x2
399:               DisplayBuf[1]++; //setting #3
02A7  3001     MOVLW 0x1
02A8  0140     MOVLB 0x0
02A9  00E2     MOVWF 0x62
02AA  0862     MOVF 0x62, W
02AB  07C0     ADDWF 0x40, F
400:               OtherSetInc(1, 0, &HourTypeStore, HourType);//insert hour format here
02AC  01D8     CLRF min
02AD  30F2     MOVLW 0xF2
02AE  00E2     MOVWF 0x62
02AF  0862     MOVF 0x62, W
02B0  00D9     MOVWF eeaddr
02B1  083A     MOVF HourType, W
02B2  00E3     MOVWF 0x63
02B3  01E4     CLRF 0x64
02B4  0863     MOVF 0x63, W
02B5  00DA     MOVWF value
02B6  0864     MOVF 0x64, W
02B7  00DB     MOVWF i2creg
02B8  3001     MOVLW 0x1
02B9  3183     MOVLP 0x3
02BA  2324     CALL 0x324
02BB  3182     MOVLP 0x2
401:               DisplayBuf[1]++; //setting #4
02BC  3001     MOVLW 0x1
02BD  0140     MOVLB 0x0
02BE  00E2     MOVWF 0x62
02BF  0862     MOVF 0x62, W
02C0  07C0     ADDWF 0x40, F
402:               BCDSetInc(0x31, 0x1, DateReg); //do the date setting
02C1  01DA     CLRF value
02C2  0ADA     INCF value, F
02C3  3004     MOVLW 0x4
02C4  00E2     MOVWF 0x62
02C5  0862     MOVF 0x62, W
02C6  00DB     MOVWF i2creg
02C7  3031     MOVLW 0x31
02C8  3184     MOVLP 0x4
02C9  2469     CALL 0x469
02CA  3182     MOVLP 0x2
403:               DisplayBuf[1]++; //setting #5
02CB  3001     MOVLW 0x1
02CC  0140     MOVLB 0x0
02CD  00E2     MOVWF 0x62
02CE  0862     MOVF 0x62, W
02CF  07C0     ADDWF 0x40, F
404:               BCDSetInc(0x12, 0x1, MonthReg); //do the month setting
02D0  01DA     CLRF value
02D1  0ADA     INCF value, F
02D2  3005     MOVLW 0x5
02D3  00E2     MOVWF 0x62
02D4  0862     MOVF 0x62, W
02D5  00DB     MOVWF i2creg
02D6  3012     MOVLW 0x12
02D7  3184     MOVLP 0x4
02D8  2469     CALL 0x469
02D9  3182     MOVLP 0x2
405:               DisplayBuf[1]++; //setting #6
02DA  3001     MOVLW 0x1
02DB  0140     MOVLB 0x0
02DC  00E2     MOVWF 0x62
02DD  0862     MOVF 0x62, W
02DE  07C0     ADDWF 0x40, F
406:               BCDSetInc(0x99, 0, MonthReg); //do the year setting
02DF  01DA     CLRF value
02E0  3005     MOVLW 0x5
02E1  00E2     MOVWF 0x62
02E2  0862     MOVF 0x62, W
02E3  00DB     MOVWF i2creg
02E4  3099     MOVLW 0x99
02E5  3184     MOVLP 0x4
02E6  2469     CALL 0x469
02E7  3182     MOVLP 0x2
407:               DisplayBuf[1]++; //setting #7
02E8  3001     MOVLW 0x1
02E9  0140     MOVLB 0x0
02EA  00E2     MOVWF 0x62
02EB  0862     MOVF 0x62, W
02EC  07C0     ADDWF 0x40, F
408:               //insert date format setting here
409:               DisplayBuf[1]++; //setting #8
02ED  3001     MOVLW 0x1
02EE  00E2     MOVWF 0x62
02EF  0862     MOVF 0x62, W
02F0  07C0     ADDWF 0x40, F
410:               BCDSetInc(0x23, 0, BlankStarti2c); //do the blank start hour setting
02F1  01DA     CLRF value
02F2  3014     MOVLW 0x14
02F3  00E2     MOVWF 0x62
02F4  0862     MOVF 0x62, W
02F5  00DB     MOVWF i2creg
02F6  3023     MOVLW 0x23
02F7  3184     MOVLP 0x4
02F8  2469     CALL 0x469
02F9  3182     MOVLP 0x2
411:               EEPROM_Write(&BlankStartStore, BlankStart); //save the setting
02FA  0140     MOVLB 0x0
02FB  0839     MOVF BlankStart, W
02FC  00E2     MOVWF 0x62
02FD  0862     MOVF 0x62, W
02FE  00F1     MOVWF data
02FF  30F1     MOVLW 0xF1
0300  318C     MOVLP 0xC
0301  24A5     CALL 0x4A5
0302  3182     MOVLP 0x2
412:               DisplayBuf[1]++; //setting #9
0303  3001     MOVLW 0x1
0304  0140     MOVLB 0x0
0305  00E2     MOVWF 0x62
0306  0862     MOVF 0x62, W
0307  07C0     ADDWF 0x40, F
413:               BCDSetInc(0x23, 0, BlankEndi2c); //do the blank ending hour setting
0308  01DA     CLRF value
0309  3015     MOVLW 0x15
030A  00E2     MOVWF 0x62
030B  0862     MOVF 0x62, W
030C  00DB     MOVWF i2creg
030D  3023     MOVLW 0x23
030E  3184     MOVLP 0x4
030F  2469     CALL 0x469
0310  3182     MOVLP 0x2
414:               EEPROM_Write(&BlankEndStore, BlankEnd); //save the setting
0311  0140     MOVLB 0x0
0312  0838     MOVF BlankEnd, W
0313  00E2     MOVWF 0x62
0314  0862     MOVF 0x62, W
0315  00F1     MOVWF data
0316  30F0     MOVLW 0xF0
0317  318C     MOVLP 0xC
0318  24A5     CALL 0x4A5
415:               DisplayBuf[0]++; //setting #10
0319  3001     MOVLW 0x1
031A  0140     MOVLB 0x0
031B  00E2     MOVWF 0x62
031C  0862     MOVF 0x62, W
031D  07BF     ADDWF DisplayBuf, F
416:               DisplayBuf[1] = 0;
031E  01C0     CLRF 0x40
417:               //insert time adjust here
418:               DisplayBuf[1]++; //setting #11
031F  3001     MOVLW 0x1
0320  00E2     MOVWF 0x62
0321  0862     MOVF 0x62, W
0322  07C0     ADDWF 0x40, F
419:               //insert brightness here
420:               
421:               
422:           }
0323  0008     RETURN
423:           /**
424:            End of File
425:           */
---  D:/Documents/EAGLE/projects/Divergence Meter/Program/F18444 Rebuild.X/Subroutines.c  ---------------
1:             /* 
2:              * File:   Subfunctions.c
3:              * Author: /u/xilyflob
4:              */
5:             
6:             #include "Variables.h"
7:             #include "Subroutines.h"
8:             #include "mcc_generated_files/mcc.h"
9:             
10:            void SW1Interrupt(void)
11:            {
12:                _delay(10000); //button debouce
0A97  300D     MOVLW 0xD
0A98  00F0     MOVWF __pcstackCOMMON
0A99  30FC     MOVLW 0xFC
0A9A  0B89     DECFSZ WREG, F
0A9B  2A9A     GOTO 0x29A
0A9C  0BF0     DECFSZ __pcstackCOMMON, F
0A9D  2A9A     GOTO 0x29A
13:                while (SW1_GetValue()){} //chillin, waiting for button release
0A9E  0140     MOVLB 0x0
0A9F  180E     BTFSC PORTC, 0x0
0AA0  2A9E     GOTO 0x29E
14:                GoDM = 1; //set the flag to go the DM function
0AA1  157C     BSF NegWL, 0x2
15:            }
0AA2  0008     RETURN
16:            
17:            void SW2Interrupt(void)
18:            {
19:                _delay(10000); //button debouce
0AA3  300D     MOVLW 0xD
0AA4  00F0     MOVWF __pcstackCOMMON
0AA5  30FC     MOVLW 0xFC
0AA6  0B89     DECFSZ WREG, F
0AA7  2AA6     GOTO 0x2A6
0AA8  0BF0     DECFSZ __pcstackCOMMON, F
0AA9  2AA6     GOTO 0x2A6
20:                while (SW2_GetValue()){} //chillin, waiting for button release
0AAA  0140     MOVLB 0x0
0AAB  188E     BTFSC PORTC, 0x1
0AAC  2AAA     GOTO 0x2AA
21:                GoDate = 1; //set the flag to go to the date
0AAD  15FC     BSF NegWL, 0x3
22:            }
0AAE  0008     RETURN
23:            
24:            void TubesOff(void)
25:            {
26:                PWM6CONbits.PWM6EN = 0; //turn of the PWM generator
0A27  0147     MOVLB 0x7
0A28  138E     BCF PWM6CON, 0x7
27:                BL_SetLow(); //blank the tubes
0A29  0140     MOVLB 0x0
0A2A  121A     BCF LATC, 0x4
28:                HVPS_ENABLE_SetLow(); //turn off the HVPS
0A2B  139A     BCF LATC, 0x7
29:            }
0A2C  0008     RETURN
30:            
31:            void TubesOn(void)
32:            {
33:                PWM6_LoadDutyValue(((5190 * Brightness) / 100)); //Load the brightness value into the PWM generator
0D67  3064     MOVLW 0x64
0D68  00F7     MOVWF divisor
0D69  3000     MOVLW 0x0
0D6A  00F8     MOVWF readVal
0D6B  083B     MOVF Brightness, W
0D6C  00D3     MOVWF reg
0D6D  01D4     CLRF data
0D6E  0853     MOVF reg, W
0D6F  00F1     MOVWF data
0D70  0854     MOVF data, W
0D71  00F2     MOVWF input
0D72  3046     MOVLW 0x46
0D73  00F3     MOVWF addr
0D74  3014     MOVLW 0x14
0D75  00F4     MOVWF buffer
0D76  318C     MOVLP 0xC
0D77  246D     CALL 0x46D
0D78  318D     MOVLP 0xD
0D79  0872     MOVF input, W
0D7A  00FA     MOVWF readValLow
0D7B  0871     MOVF data, W
0D7C  00F9     MOVWF dividend
0D7D  3186     MOVLP 0x6
0D7E  263A     CALL 0x63A
0D7F  318D     MOVLP 0xD
0D80  0878     MOVF readVal, W
0D81  00D0     MOVWF 0x50
0D82  0877     MOVF divisor, W
0D83  00CF     MOVWF dutyValue
0D84  318C     MOVLP 0xC
0D85  240A     CALL 0x40A
34:                PWM6CONbits.PWM6EN = 1; //turn on the PWM generator
0D86  178E     BSF PORTC, 0x7
35:                BL_SetHigh(); //unblank the tubes
0D87  0140     MOVLB 0x0
0D88  161A     BSF LATC, 0x4
36:                HVPS_ENABLE_SetHigh(); //turn on the HVPS
0D89  179A     BSF LATC, 0x7
37:            }
0D8A  0008     RETURN
38:            
39:            void NumSplit(uint8_t input)
0B58  00F2     MOVWF input
40:            {
41:                BCDSplit[1] = input; //get the input into a generally available variable
0B59  0872     MOVF input, W
0B5A  00F1     MOVWF data
0B5B  0871     MOVF data, W
0B5C  00A9     MOVWF 0x29
42:                BCDSplit[0] = 0; //zero out the other half
0B5D  01A8     CLRF BCDSplit
43:                while(BCDSplit[1] >= 10) //while we are above 10
0B5E  300A     MOVLW 0xA
0B5F  0229     SUBWF 0x29, W
0B60  1C03     BTFSS STATUS, 0x0
0B61  0008     RETURN
0B68  2B5E     GOTO 0x35E
44:                {
45:                    BCDSplit[0]++; //increment tens place
0B62  3001     MOVLW 0x1
0B63  00F1     MOVWF data
0B64  0871     MOVF data, W
0B65  07A8     ADDWF BCDSplit, F
46:                    BCDSplit[1] -= 10; //take 10 off of the orig value
0B66  300A     MOVLW 0xA
0B67  02A9     SUBWF 0x29, F
47:                }
48:            }
49:            
50:            uint8_t Bin2BCD(void)
51:            {
52:                return (((BCDSplit[0] << 4) | BCDSplit[1])); //combine the two values into the packed BCD
53:            }
54:            
55:            void BCD2Bin(uint8_t input)
0B69  00F2     MOVWF input
56:            {
57:                BCDSplit[1] = input & 0xF; //get ones place
0B6A  0872     MOVF input, W
0B6B  390F     ANDLW 0xF
0B6C  00F1     MOVWF data
0B6D  0871     MOVF data, W
0B6E  00A9     MOVWF 0x29
58:                input = (input >> 4) | (input << 4); //swapf equivelent, will trade the positions of the digits in the BCD
0B6F  3004     MOVLW 0x4
0B70  00F1     MOVWF data
0B71  0C72     RRF input, W
0B72  0CF2     RRF input, F
0B73  0BF1     DECFSZ data, F
0B74  2B71     GOTO 0x371
59:                BCDSplit[0] = input & 0xF; //get tens place
0B75  0872     MOVF input, W
0B76  390F     ANDLW 0xF
0B77  00F1     MOVWF data
0B78  0871     MOVF data, W
0B79  00A8     MOVWF BCDSplit
60:            }
0B7A  0008     RETURN
61:            
62:            void SplitLoad(uint8_t first)
0B7B  00F2     MOVWF input
63:            {
64:                DisplayBuf[first] = BCDSplit[0]; //tens place goes in the first tube
0B7C  0828     MOVF BCDSplit, W
0B7D  00F1     MOVWF data
0B7E  0872     MOVF input, W
0B7F  3E3F     ADDLW 0x3F
0B80  0086     MOVWF FSR1
0B81  0187     CLRF FSR1H
0B82  0871     MOVF data, W
0B83  0081     MOVWF INDF1
65:                DisplayBuf[first + 1] = BCDSplit[1]; //ones place goes in the second
0B84  0829     MOVF 0x29, W
0B85  00F1     MOVWF data
0B86  0872     MOVF input, W
0B87  3E40     ADDLW 0x40
0B88  0086     MOVWF FSR1
0B89  0187     CLRF FSR1H
0B8A  0871     MOVF data, W
0B8B  0081     MOVWF INDF1
66:            }
0B8C  0008     RETURN
67:            
68:            uint8_t Buttons(void)
69:            {
70:                uint16_t presstime = 500; //how long a long press is in ms (user definable)
0ED5  30F4     MOVLW 0xF4
0ED6  00F2     MOVWF input
0ED7  3001     MOVLW 0x1
0ED8  00F3     MOVWF addr
71:                buttoncounter = 13; //13 is the base value to account for the 10ms debounce and a consistent 3 interrupt undershoot that the timer does
0ED9  300D     MOVLW 0xD
0EDA  0140     MOVLB 0x0
0EDB  00AE     MOVWF buttoncounter
0EDC  3000     MOVLW 0x0
0EDD  00AF     MOVWF 0x2F
72:                
73:                while(1) //keep watching forever
74:                {    
75:                    if (SW1_GetValue()) //looking for SW1 press
0EDE  1C0E     BTFSS PORTC, 0x0
0EDF  2EFD     GOTO 0x6FD
76:                    {
77:                        _delay(10000); //basic button debounce
0EE0  300D     MOVLW 0xD
0EE1  00F1     MOVWF data
0EE2  30FC     MOVLW 0xFC
0EE3  0B89     DECFSZ WREG, F
0EE4  2EE3     GOTO 0x6E3
0EE5  0BF1     DECFSZ data, F
0EE6  2EE3     GOTO 0x6E3
78:                        TMR4_Start(); //start the timer, 1ms period, interrupt enabled
0EE7  3189     MOVLP 0x9
0EE8  21B3     CALL 0x1B3
0EE9  318E     MOVLP 0xE
79:                        while (SW1_GetValue()){} //wait for button release, it would take 50+ days for the counter to overflow, so i'm gonna say that forever is an ok loop
0EEA  0140     MOVLB 0x0
0EEB  180E     BTFSC PORTC, 0x0
0EEC  2EEA     GOTO 0x6EA
80:                        TMR4_Stop(); //stop the timer
0EED  3189     MOVLP 0x9
0EEE  21B6     CALL 0x1B6
0EEF  318E     MOVLP 0xE
81:                        if (buttoncounter > presstime) //more than 500ms?
0EF0  0140     MOVLB 0x0
0EF1  082F     MOVF 0x2F, W
0EF2  0273     SUBWF addr, W
0EF3  1D03     BTFSS STATUS, 0x2
0EF4  2EF7     GOTO 0x6F7
0EF5  082E     MOVF buttoncounter, W
0EF6  0272     SUBWF input, W
0EF7  1803     BTFSC STATUS, 0x0
0EF8  2EFB     GOTO 0x6FB
82:                        {
83:                            return 2; //end function, return 2
0EF9  3002     MOVLW 0x2
0EFA  0008     RETURN
84:                        }
85:                        return 1; //end function, return 1
0EFB  3001     MOVLW 0x1
0EFC  0008     RETURN
86:                    }
87:                    else if (SW2_GetValue()) //or looking for SW2 press
0EFD  1C8E     BTFSS PORTC, 0x1
0EFE  2EDE     GOTO 0x6DE
88:                    {
89:                        _delay(10000); //basic button debounce
0EFF  300D     MOVLW 0xD
0F00  00F1     MOVWF data
0F01  30FC     MOVLW 0xFC
0F02  0B89     DECFSZ WREG, F
0F03  2F02     GOTO 0x702
0F04  0BF1     DECFSZ data, F
0F05  2F02     GOTO 0x702
90:                        while (SW2_GetValue()){} //wait for button release
0F06  0140     MOVLB 0x0
0F07  188E     BTFSC PORTC, 0x1
0F08  2F06     GOTO 0x706
91:                        return 3; //end function, return 3
0F09  3003     MOVLW 0x3
92:                    }
93:                }
94:            }
0F0A  0008     RETURN
95:            
96:            void EmptyTubes(void)
97:            {
98:                for (Pos=8; Pos--;) //this will loop until all values in the display buffer are 10, a number that will not display anything
0B8D  3008     MOVLW 0x8
0B8E  00F1     MOVWF data
0B8F  0871     MOVF data, W
0B90  0140     MOVLB 0x0
0B91  00BE     MOVWF Pos
99:                {
100:                   DisplayBuf[Pos] = 10; //change current value to 10
0B97  300A     MOVLW 0xA
0B98  00F1     MOVWF data
0B99  083E     MOVF Pos, W
0B9A  3E3F     ADDLW 0x3F
0B9B  0086     MOVWF FSR1
0B9C  0187     CLRF FSR1H
0B9D  0871     MOVF data, W
0B9E  0081     MOVWF INDF1
101:               }
0B92  3001     MOVLW 0x1
0B93  02BE     SUBWF Pos, F
0B94  0A3E     INCF Pos, W
0B95  1903     BTFSC STATUS, 0x2
0B96  0008     RETURN
0B9F  2B92     GOTO 0x392
102:           }
103:           
104:           void BCDSetInc(uint8_t max, uint8_t min, uint8_t i2creg)
0469  00E0     MOVWF max
105:           {
106:               uint8_t value; //value of the setting being worked on
107:               
108:               if (i2creg == BlankStarti2c) //if we faked our way in here
046A  3014     MOVLW 0x14
046B  065B     XORWF i2creg, W
046C  1D03     BTFSS STATUS, 0x2
046D  2C70     GOTO 0x470
109:                   value = BlankStart; //get the starting blank hour
046E  0839     MOVF BlankStart, W
046F  2C75     GOTO 0x475
110:               else if (i2creg == BlankEndi2c) //the other fake entry
0470  3015     MOVLW 0x15
0471  065B     XORWF i2creg, W
0472  1D03     BTFSS STATUS, 0x2
0473  2C78     GOTO 0x478
111:                   value = BlankEnd; //get the ending blank hour
0474  0838     MOVF BlankEnd, W
0475  00DC     MOVWF 0x5C
0476  085C     MOVF 0x5C, W
0477  2C82     GOTO 0x482
112:               else //most of the time we get here
113:                   value = i2c_read1ByteRegister(ClockAddress, i2creg); //get the value from the clock for the setting
0478  085B     MOVF i2creg, W
0479  00DC     MOVWF 0x5C
047A  085C     MOVF 0x5C, W
047B  00D3     MOVWF reg
047C  3068     MOVLW 0x68
047D  3187     MOVLP 0x7
047E  2722     CALL 0x722
047F  3184     MOVLP 0x4
0480  00DD     MOVWF WLtype
0481  085D     MOVF WLtype, W
0482  00E1     MOVWF value
114:               OldSet = value; //copy for use later
0483  0861     MOVF value, W
0484  00DC     MOVWF 0x5C
0485  085C     MOVF 0x5C, W
0486  00B6     MOVWF OldSet
115:               while(1) //foreverrrrrrrr
116:               {
117:                   BCD2Bin(value); //real numbers for display
0487  0861     MOVF value, W
0488  318B     MOVLP 0xB
0489  2369     CALL 0x369
048A  3184     MOVLP 0x4
118:                   SplitLoad(6); //load to buffer
048B  3006     MOVLW 0x6
048C  318B     MOVLP 0xB
048D  237B     CALL 0x37B
048E  3184     MOVLP 0x4
119:                   Loader(); //load it to the display
048F  318E     MOVLP 0xE
0490  266F     CALL 0x66F
0491  3184     MOVLP 0x4
120:                   _delay(debounce); //debounce the tubes
0492  3015     MOVLW 0x15
0493  0140     MOVLB 0x0
0494  00DC     MOVWF 0x5C
0495  30C6     MOVLW 0xC6
0496  0B89     DECFSZ WREG, F
0497  2C96     GOTO 0x496
0498  0BDC     DECFSZ 0x5C, F
0499  2C96     GOTO 0x496
049A  0000     NOP
121:                   Temp = Buttons(); //get a button press
049B  318E     MOVLP 0xE
049C  26D5     CALL 0x6D5
049D  3184     MOVLP 0x4
049E  00DC     MOVWF 0x5C
049F  085C     MOVF 0x5C, W
04A0  00B7     MOVWF Temp
122:                   if (Temp == 3) //if SW2 is pressed
04A1  3003     MOVLW 0x3
04A2  0637     XORWF Temp, W
04A3  1903     BTFSC STATUS, 0x2
04A4  2CDC     GOTO 0x4DC
123:                       break; //number changing done, leave the while loop
124:                   else if (Temp == 1) //if SW1 is short pressed
04A5  0337     DECF Temp, W
04A6  1D03     BTFSS STATUS, 0x2
04A7  2CBF     GOTO 0x4BF
125:                   {
126:                       value++; //increment the setting value
04A8  3001     MOVLW 0x1
04A9  00DC     MOVWF 0x5C
04AA  085C     MOVF 0x5C, W
04AB  07E1     ADDWF value, F
127:                       if ((value & 0xF) == 0xA)
04AC  300F     MOVLW 0xF
04AD  0561     ANDWF value, W
04AE  00DC     MOVWF 0x5C
04AF  300A     MOVLW 0xA
04B0  065C     XORWF 0x5C, W
04B1  1D03     BTFSS STATUS, 0x2
04B2  2CB9     GOTO 0x4B9
128:                           value = (value & 0xF0) + 10;
04B3  0861     MOVF value, W
04B4  39F0     ANDLW 0xF0
04B5  3E0A     ADDLW 0xA
04B6  00DC     MOVWF 0x5C
04B7  085C     MOVF 0x5C, W
04B8  00E1     MOVWF value
129:                       if (value > max) //if the value is greater than the max value
04B9  0861     MOVF value, W
04BA  0260     SUBWF max, W
04BB  1803     BTFSC STATUS, 0x0
04BC  2C87     GOTO 0x487
130:                           value = min; //wrap to min
04BD  085A     MOVF value, W
04BE  2CD5     GOTO 0x4D5
131:                   }
132:                   else //if SW1 is long pressed
133:                   {
134:                       if (value - min == 0) //this evaluating true means that any more decrement would exceed the minimum, so we wrap to the max
04BF  0861     MOVF value, W
04C0  00DC     MOVWF 0x5C
04C1  01DD     CLRF WLtype
04C2  085D     MOVF WLtype, W
04C3  00DF     MOVWF seedadr
04C4  085A     MOVF value, W
04C5  025C     SUBWF 0x5C, W
04C6  00DE     MOVWF max
04C7  1C03     BTFSS STATUS, 0x0
04C8  03DF     DECF seedadr, F
04C9  085E     MOVF max, W
04CA  045F     IORWF seedadr, W
04CB  1D03     BTFSS STATUS, 0x2
04CC  2CCF     GOTO 0x4CF
135:                           value = max; //wrap to the maximum value
04CD  0860     MOVF max, W
04CE  2CD5     GOTO 0x4D5
136:                       else
137:                       {
138:                           if ((value & 0xF) == 0) //if the ones place is 0
04CF  0861     MOVF value, W
04D0  390F     ANDLW 0xF
04D1  1D03     BTFSS STATUS, 0x2
04D2  2CD9     GOTO 0x4D9
139:                               value = (value + 9) - 10; //add 9, then subtract 10
04D3  0861     MOVF value, W
04D4  3EFF     ADDLW 0xFF
04D5  00DC     MOVWF 0x5C
04D6  085C     MOVF 0x5C, W
04D7  00E1     MOVWF value
04D8  2C87     GOTO 0x487
140:                           else
141:                               value--; //decrement the setting value
04D9  3001     MOVLW 0x1
04DA  02E1     SUBWF value, F
04DB  2C87     GOTO 0x487
142:                       }
143:                   }
144:               }
145:               if (value != OldSet) //if the value changed
04DC  0861     MOVF value, W
04DD  0636     XORWF OldSet, W
04DE  1903     BTFSC STATUS, 0x2
04DF  0008     RETURN
146:               {
147:                   if (i2creg == BlankStarti2c) //for the blank starting hour
04E0  3014     MOVLW 0x14
04E1  065B     XORWF i2creg, W
04E2  1D03     BTFSS STATUS, 0x2
04E3  2CE9     GOTO 0x4E9
148:                       BlankStart = value;
04E4  0861     MOVF value, W
04E5  00DC     MOVWF 0x5C
04E6  085C     MOVF 0x5C, W
04E7  00B9     MOVWF BlankStart
04E8  0008     RETURN
149:                   else if (i2creg == BlankEndi2c) //for the blank ending hour
04E9  3015     MOVLW 0x15
04EA  065B     XORWF i2creg, W
04EB  1D03     BTFSS STATUS, 0x2
04EC  2CF2     GOTO 0x4F2
150:                       BlankEnd = value;
04ED  0861     MOVF value, W
04EE  00DC     MOVWF 0x5C
04EF  085C     MOVF 0x5C, W
04F0  00B8     MOVWF BlankEnd
04F1  0008     RETURN
151:                   else //everything else
152:                   {
153:                       i2c_write1ByteRegister(ClockAddress, i2creg, value); //write it to the place we got it
04F2  085B     MOVF i2creg, W
04F3  00DC     MOVWF 0x5C
04F4  085C     MOVF 0x5C, W
04F5  00D3     MOVWF reg
04F6  0861     MOVF value, W
04F7  00DD     MOVWF WLtype
04F8  085D     MOVF WLtype, W
04F9  00D4     MOVWF data
04FA  3068     MOVLW 0x68
04FB  318D     MOVLP 0xD
04FC  25E3     CALL 0x5E3
04FD  3184     MOVLP 0x4
154:                       if (i2creg == MinutesReg) //if we were doing the minutes
04FE  0140     MOVLB 0x0
04FF  035B     DECF i2creg, W
0500  1D03     BTFSS STATUS, 0x2
0501  0008     RETURN
155:                           i2c_write1ByteRegister(ClockAddress, SecondsReg, 0); //clear the seconds register
0502  01D3     CLRF reg
0503  01D4     CLRF data
0504  3068     MOVLW 0x68
0505  318D     MOVLP 0xD
0506  25E3     CALL 0x5E3
156:                   }
157:               }
158:           }
159:           
160:           void OtherSetInc(uint8_t max, uint8_t min, uint8_t eeaddr, uint8_t *value)
0324  00DE     MOVWF max
161:           {
162:               OldSet = value; //copy for use later
0325  085A     MOVF value, W
0326  00DC     MOVWF 0x5C
0327  085C     MOVF 0x5C, W
0328  00B6     MOVWF OldSet
163:               while(1) //changing loop
0329  0140     MOVLB 0x0
032A  0859     MOVF eeaddr, W
032B  00DC     MOVWF 0x5C
032C  01DD     CLRF WLtype
032D  3000     MOVLW 0x0
032E  065D     XORWF WLtype, W
164:               {
165:                   if (eeaddr == &HourTypeStore) //if we are doing 12/24 mode
032F  1D03     BTFSS STATUS, 0x2
0330  2B33     GOTO 0x333
0331  30F2     MOVLW 0xF2
0332  065C     XORWF 0x5C, W
0333  1D03     BTFSS STATUS, 0x2
0334  2B47     GOTO 0x347
166:                   {
167:                       DisplayBuf[6] = 1; //start assuming 12 hour setting is desired
0335  01C5     CLRF 0x45
0336  0AC5     INCF 0x45, F
168:                       DisplayBuf[7] = 2;
0337  3002     MOVLW 0x2
0338  00DC     MOVWF 0x5C
0339  085C     MOVF 0x5C, W
033A  00C6     MOVWF 0x46
169:                       if (HourType == 0) //if in 24 hour mode though
033B  083A     MOVF HourType, W
033C  1D03     BTFSS STATUS, 0x2
033D  2B4F     GOTO 0x34F
170:                       {
171:                           DisplayBuf[6] = 2; //swap to 24 if 24 is selected
033E  3002     MOVLW 0x2
033F  00DC     MOVWF 0x5C
0340  085C     MOVF 0x5C, W
0341  00C5     MOVWF 0x45
172:                           DisplayBuf[7] = 4;
0342  3004     MOVLW 0x4
0343  00DC     MOVWF 0x5C
0344  085C     MOVF 0x5C, W
0345  00C6     MOVWF 0x46
0346  2B4F     GOTO 0x34F
173:                       }
174:                   }
175:                   else //everything else
176:                   {
177:                       NumSplit(value); //split the stored value
0347  085A     MOVF value, W
0348  318B     MOVLP 0xB
0349  2358     CALL 0x358
034A  3183     MOVLP 0x3
178:                       SplitLoad(6); //load to the buffer
034B  3006     MOVLW 0x6
034C  318B     MOVLP 0xB
034D  237B     CALL 0x37B
034E  3183     MOVLP 0x3
179:                   }
180:                   Loader(); //Display the value
034F  318E     MOVLP 0xE
0350  266F     CALL 0x66F
0351  3183     MOVLP 0x3
181:                   Temp = Buttons(); //get a button press
0352  318E     MOVLP 0xE
0353  26D5     CALL 0x6D5
0354  3183     MOVLP 0x3
0355  00DC     MOVWF 0x5C
0356  085C     MOVF 0x5C, W
0357  00B7     MOVWF Temp
182:                   if (Temp == 3) //if SW2 was pressed
0358  3003     MOVLW 0x3
0359  0637     XORWF Temp, W
035A  1903     BTFSC STATUS, 0x2
035B  2BB7     GOTO 0x3B7
183:                       break;
184:                   else if (Temp == 1) //if SW1 is short pressed
035C  0337     DECF Temp, W
035D  1D03     BTFSS STATUS, 0x2
035E  2B70     GOTO 0x370
185:                   {
186:                       value ++; //increment the ones
035F  3001     MOVLW 0x1
0360  07DA     ADDWF value, F
0361  3000     MOVLW 0x0
0362  3DDB     ADDWFC i2creg, F
187:                       if (value > max) //if we are above the maximum
0363  085E     MOVF max, W
0364  00DC     MOVWF 0x5C
0365  01DD     CLRF WLtype
0366  085B     MOVF i2creg, W
0367  025D     SUBWF WLtype, W
0368  1D03     BTFSS STATUS, 0x2
0369  2B6C     GOTO 0x36C
036A  085A     MOVF value, W
036B  025C     SUBWF 0x5C, W
036C  1803     BTFSC STATUS, 0x0
036D  2B87     GOTO 0x387
188:                           value = min; //wrap to min
036E  0858     MOVF min, W
036F  2B7C     GOTO 0x37C
189:                   }
190:                   else //if SW1 is long pressed
191:                   {
192:                       if (value -  min == 0) //if currently at the minimum
0370  085B     MOVF i2creg, W
0371  00DD     MOVWF WLtype
0372  0858     MOVF min, W
0373  025A     SUBWF value, W
0374  00DC     MOVWF 0x5C
0375  1C03     BTFSS STATUS, 0x0
0376  03DD     DECF WLtype, F
0377  085C     MOVF 0x5C, W
0378  045D     IORWF WLtype, W
0379  1D03     BTFSS STATUS, 0x2
037A  2B83     GOTO 0x383
193:                           value = max; //wrap to max
037B  085E     MOVF max, W
037C  00DC     MOVWF 0x5C
037D  01DD     CLRF WLtype
037E  085C     MOVF 0x5C, W
037F  00DA     MOVWF value
0380  085D     MOVF WLtype, W
0381  00DB     MOVWF i2creg
0382  2B87     GOTO 0x387
194:                       else //otherwise
195:                           value--; //decrement value
0383  3001     MOVLW 0x1
0384  02DA     SUBWF value, F
0385  3000     MOVLW 0x0
0386  3BDB     SUBWFB i2creg, F
196:                   }
0387  0859     MOVF eeaddr, W
0388  00DC     MOVWF 0x5C
0389  01DD     CLRF WLtype
038A  3000     MOVLW 0x0
038B  065D     XORWF WLtype, W
197:                   if (eeaddr == &BrightnessStore)
038C  1D03     BTFSS STATUS, 0x2
038D  2B90     GOTO 0x390
038E  30F3     MOVLW 0xF3
038F  065C     XORWF 0x5C, W
0390  1D03     BTFSS STATUS, 0x2
0391  2B96     GOTO 0x396
198:                       Brightness = value;
0392  085A     MOVF value, W
0393  00DC     MOVWF 0x5C
0394  085C     MOVF 0x5C, W
0395  00BB     MOVWF Brightness
199:                       PWM6_LoadDutyValue(((5190 * (Brightness)) / 100)); //Load the brightness value into the PWM generator
0396  3064     MOVLW 0x64
0397  00F7     MOVWF divisor
0398  3000     MOVLW 0x0
0399  00F8     MOVWF readVal
039A  083B     MOVF Brightness, W
039B  00DC     MOVWF 0x5C
039C  01DD     CLRF WLtype
039D  085C     MOVF 0x5C, W
039E  00F1     MOVWF data
039F  085D     MOVF WLtype, W
03A0  00F2     MOVWF input
03A1  3046     MOVLW 0x46
03A2  00F3     MOVWF addr
03A3  3014     MOVLW 0x14
03A4  00F4     MOVWF buffer
03A5  318C     MOVLP 0xC
03A6  246D     CALL 0x46D
03A7  3183     MOVLP 0x3
03A8  0872     MOVF input, W
03A9  00FA     MOVWF readValLow
03AA  0871     MOVF data, W
03AB  00F9     MOVWF dividend
03AC  3186     MOVLP 0x6
03AD  263A     CALL 0x63A
03AE  3183     MOVLP 0x3
03AF  0878     MOVF readVal, W
03B0  00D0     MOVWF 0x50
03B1  0877     MOVF divisor, W
03B2  00CF     MOVWF dutyValue
03B3  318C     MOVLP 0xC
03B4  240A     CALL 0x40A
03B5  3183     MOVLP 0x3
03B6  2B29     GOTO 0x329
200:                       
201:               }
202:               if (value != OldSet) //if the value changed
03B7  0836     MOVF OldSet, W
03B8  00DC     MOVWF 0x5C
03B9  01DD     CLRF WLtype
03BA  085D     MOVF WLtype, W
03BB  065B     XORWF i2creg, W
03BC  1D03     BTFSS STATUS, 0x2
03BD  2BC0     GOTO 0x3C0
03BE  085C     MOVF 0x5C, W
03BF  065A     XORWF value, W
03C0  1903     BTFSC STATUS, 0x2
03C1  0008     RETURN
203:                   EEPROM_Write(eeaddr, value); //save to the setting storage
03C2  085A     MOVF value, W
03C3  00DC     MOVWF 0x5C
03C4  085C     MOVF 0x5C, W
03C5  00F1     MOVWF data
03C6  0859     MOVF eeaddr, W
03C7  318C     MOVLP 0xC
03C8  24A5     CALL 0x4A5
204:           }
03C9  0008     RETURN
205:           
206:           uint8_t EEPROM_Read(uint8_t addr)
0A63  00F1     MOVWF data
207:           {
208:               NVMCON1bits.NVMREGS = 1; //this is a direct copy from eeprom_routines.h
0A64  0150     MOVLB 0x10
0A65  171E     BSF NVMCON1, 0x6
209:               NVMADRL = (addr) & 0xFFu; //it is here for easier code reading
0A66  0871     MOVF 0x871, W
0A67  009A     MOVWF NVMADR
210:               NVMADRH = 0x70;
0A68  3070     MOVLW 0x70
0A69  009B     MOVWF NVMADRH
211:               NVMCON1bits.RD = 1;
0A6A  141E     BSF NVMCON1, 0x0
212:               return NVMDATL;
0A6B  081C     MOVF NVMDAT, W
213:           }
0A6C  0008     RETURN
214:           
215:           void EEPROM_Write(uint8_t addr, uint8_t data)
0CA5  00F2     MOVWF 0x872
216:           {
217:               while (NVMCON1bits.WR){} //this is a direct copy from eeprom_routines.h
0CA6  0150     MOVLB 0x10
0CA7  189E     BTFSC NVMCON1, 0x1
0CA8  2CA6     GOTO 0x4A6
218:           	NVMCON1bits.NVMREGS = 1; //it is here for easier code reading
0CA9  171E     BSF NVMCON1, 0x6
219:           	NVMADRL = (addr) & 0xFFu;
0CAA  0872     MOVF 0x872, W
0CAB  009A     MOVWF NVMADR
220:           	NVMADRH = 0x70;
0CAC  3070     MOVLW 0x70
0CAD  009B     MOVWF NVMADRH
221:           	NVMDATH = 0;
0CAE  019D     CLRF NVMDATH
222:           	NVMDATL = (data) & 0xFFu;
0CAF  0871     MOVF 0x871, W
0CB0  009C     MOVWF NVMDAT
223:           	STATUSbits.CARRY = 0;
0CB1  1003     BCF STATUS, 0x0
224:           	if (INTCONbits.GIE)
0CB2  1B8B     BTFSC INTCON, 0x7
225:               {
226:           		STATUSbits.CARRY = 1;
0CB3  1403     BSF STATUS, 0x0
227:           	}
228:           	INTCONbits.GIE = 0;
0CB4  138B     BCF INTCON, 0x7
229:           	NVMCON1bits.WREN = 1;
0CB5  151E     BSF NVMCON1, 0x2
230:           	NVMCON2 = 0x55;
0CB6  3055     MOVLW 0x55
0CB7  009F     MOVWF NVMCON2
231:           	NVMCON2 = 0xAA;
0CB8  30AA     MOVLW 0xAA
0CB9  009F     MOVWF NVMCON2
232:           	NVMCON1bits.WR = 1;
0CBA  149E     BSF NVMCON1, 0x1
233:           	while (NVMCON1bits.WR){}
0CBB  189E     BTFSC NVMCON1, 0x1
0CBC  2CBB     GOTO 0x4BB
234:           	NVMCON1bits.WREN = 0;
0CBD  111E     BCF NVMCON1, 0x2
235:           	if (STATUSbits.CARRY)
0CBE  1C03     BTFSS STATUS, 0x0
0CBF  0008     RETURN
236:               {
237:           		INTCONbits.GIE = 1;
0CC0  178B     BSF INTCON, 0x7
238:           	}
239:           }
0CC1  0008     RETURN
240:           
241:           uint8_t RandomNum(uint8_t upper)
0CFE  00DA     MOVWF 0x85A
242:           {
243:               uint8_t rand_num; //the random number
244:           
245:               srand(TMR0_ReadTimer()); //randomize the randomizer
0CFF  318C     MOVLP 0xC
0D00  2488     CALL 0x488
0D01  318C     MOVLP 0xC
0D02  0872     MOVF 0x872, W
0D03  0140     MOVLB 0x0
0D04  00CC     MOVWF sign
0D05  0871     MOVF data, W
0D06  00CB     MOVWF __pcstackBANK0
0D07  318A     MOVLP 0xA
0D08  2248     CALL 0x248
0D09  318C     MOVLP 0xC
246:               rand_num = (rand() % (upper + 1)); //get the random number, the upper variable controls the upper limit
0D0A  085A     MOVF value, W
0D0B  3E01     ADDLW 0x1
0D0C  00D5     MOVWF divisor
0D0D  3000     MOVLW 0x0
0D0E  1803     BTFSC STATUS, 0x0
0D0F  3001     MOVLW 0x1
0D10  00D6     MOVWF e
0D11  318E     MOVLP 0xE
0D12  26A2     CALL 0x6A2
0D13  318C     MOVLP 0xC
0D14  0850     MOVF 0x50, W
0D15  00D8     MOVWF min
0D16  084F     MOVF dutyValue, W
0D17  00D7     MOVWF regp
0D18  318F     MOVLP 0xF
0D19  27BB     CALL 0x7BB
0D1A  0855     MOVF divisor, W
0D1B  00D9     MOVWF eeaddr
0D1C  0859     MOVF eeaddr, W
0D1D  00DB     MOVWF i2creg
247:               return rand_num; //return the number
0D1E  085B     MOVF i2creg, W
248:           }
0D1F  0008     RETURN
249:           
250:           void RandomWL(void)
251:           {
252:               uint8_t WLtype; //this will determine if a 1, 0, or nothing will go in the first tube
253:               
254:               WLtype = RandomNum(255); //get a value to set the WL type
07AD  30FF     MOVLW 0xFF
07AE  318C     MOVLP 0xC
07AF  24FE     CALL 0x4FE
07B0  3187     MOVLP 0x7
07B1  00DC     MOVWF 0x5C
07B2  085C     MOVF 0x5C, W
07B3  00DD     MOVWF WLtype
255:               NegWL = 0;
07B4  12FC     BCF NegWL, 0x5
256:               DisplayBuf[0] = 0;//a alpha WL, 93.6% chance, if we aren't anything else, this will pass through to the loader
07B5  01BF     CLRF DisplayBuf
257:               if (WLtype <= 3) //a "negative" WL, 1.6% chance
07B6  3004     MOVLW 0x4
07B7  025D     SUBWF WLtype, W
07B8  1803     BTFSC STATUS, 0x0
07B9  2FBE     GOTO 0x7BE
258:               {
259:                   DisplayBuf[0] = 1; //picked this number so it's not super obvious that a neg WL was gotten
07BA  01BF     CLRF DisplayBuf
07BB  0ABF     INCF DisplayBuf, F
260:                   NegWL = 1;
07BC  16FC     BSF NegWL, 0x5
261:               }
07BD  2FC8     GOTO 0x7C8
262:               else if (WLtype <= 15 && WLtype > 3) //a beta WL, 4.3% chance
07BE  3010     MOVLW 0x10
07BF  025D     SUBWF WLtype, W
07C0  1803     BTFSC STATUS, 0x0
07C1  2FC8     GOTO 0x7C8
07C2  3004     MOVLW 0x4
07C3  025D     SUBWF WLtype, W
07C4  1C03     BTFSS STATUS, 0x0
07C5  2FC8     GOTO 0x7C8
263:                   DisplayBuf[0] = 1;
07C6  01BF     CLRF DisplayBuf
07C7  0ABF     INCF DisplayBuf, F
264:               AnimBuf[0] = RunLength[RandomNum(7)]; //load a value for animation length for the first tube
07C8  3007     MOVLW 0x7
07C9  318C     MOVLP 0xC
07CA  24FE     CALL 0x4FE
07CB  3187     MOVLP 0x7
07CC  3E20     ADDLW 0x20
07CD  0086     MOVWF FSR1
07CE  3001     MOVLW 0x1
07CF  0087     MOVWF FSR1H
07D0  0801     MOVF INDF1, W
07D1  00DC     MOVWF 0x5C
07D2  085C     MOVF 0x5C, W
07D3  00A0     MOVWF AnimBuf
265:               for (Pos=7; Pos>2; Pos--) //load a value for animation length for the other tubes
07D4  3007     MOVLW 0x7
07D5  00DC     MOVWF 0x5C
07D6  085C     MOVF 0x5C, W
07D7  00BE     MOVWF Pos
07D8  3003     MOVLW 0x3
07D9  023E     SUBWF Pos, W
07DA  1C03     BTFSS STATUS, 0x0
07DB  2FEF     GOTO 0x7EF
266:               {                         //starting on the third tube since the point does not animate
267:                   AnimBuf[Pos] = RunLength[RandomNum(63)]; //value loading for tubes 3-8,
07DC  303F     MOVLW 0x3F
07DD  318C     MOVLP 0xC
07DE  24FE     CALL 0x4FE
07DF  3187     MOVLP 0x7
07E0  3E20     ADDLW 0x20
07E1  0086     MOVWF FSR1
07E2  3001     MOVLW 0x1
07E3  0087     MOVWF FSR1H
07E4  0801     MOVF INDF1, W
07E5  00DC     MOVWF 0x5C
07E6  083E     MOVF Pos, W
07E7  3E20     ADDLW 0x20
07E8  0086     MOVWF FSR1
07E9  0187     CLRF FSR1H
07EA  085C     MOVF 0x5C, W
07EB  0081     MOVWF INDF1
268:               }   //these values by extention will also generate the rest of the random WL
07EC  3001     MOVLW 0x1
07ED  02BE     SUBWF Pos, F
07EE  2FD8     GOTO 0x7D8
269:               AnimateRandom(); //run the animation that is now setup
07EF  3185     MOVLP 0x5
07F0  2582     CALL 0x582
270:           }
07F1  0008     RETURN
271:           
272:           void AnimateRandom(void)
273:           {
274:               while (1) //this will loop until all the numbers have settled
275:               {
276:                   Action = 0; //clear the flag
0582  127C     BCF NegWL, 0x4
277:                   if (AnimBuf[0] != 0) //if the animation has not finished for the first tube
0583  0140     MOVLB 0x0
0584  0820     MOVF AnimBuf, W
0585  1903     BTFSC STATUS, 0x2
0586  2D94     GOTO 0x594
278:                   {
279:                       AnimBuf[0]--; //decrement the animation counter
0587  3001     MOVLW 0x1
0588  02A0     SUBWF AnimBuf, F
280:                       Action = 1; //set the flag
0589  167C     BSF NegWL, 0x4
281:                       DisplayBuf[0]++; //increment the number displayed in the tube
058A  3001     MOVLW 0x1
058B  00F2     MOVWF input
058C  0872     MOVF input, W
058D  07BF     ADDWF DisplayBuf, F
282:                       if (DisplayBuf[0] == 10) //has the tube been incremented to 10?
058E  300A     MOVLW 0xA
058F  063F     XORWF DisplayBuf, W
0590  1D03     BTFSS STATUS, 0x2
0591  2D9C     GOTO 0x59C
283:                           DisplayBuf[0] = 0; //if so wrap back to 0
0592  01BF     CLRF DisplayBuf
0593  2D9C     GOTO 0x59C
284:                   }                          //as a note, no tube should be blanked when entering this function
285:                   else if (AnimBuf[0] == 0 && NegWL == 1) //if the animation has ended AND the neg WL flag
0594  0820     MOVF AnimBuf, W
0595  1903     BTFSC STATUS, 0x2
0596  1EFC     BTFSS NegWL, 0x5
0597  2D9C     GOTO 0x59C
286:                       DisplayBuf[0] = 10; //blank the tube
0598  300A     MOVLW 0xA
0599  00F2     MOVWF input
059A  0872     MOVF input, W
059B  00BF     MOVWF DisplayBuf
287:                   for (Pos=7; Pos>2; Pos--) //this will do the same thing as the above if for
059C  3007     MOVLW 0x7
059D  00F2     MOVWF input
059E  0872     MOVF input, W
059F  00BE     MOVWF Pos
05A0  3003     MOVLW 0x3
05A1  023E     SUBWF Pos, W
05A2  1C03     BTFSS STATUS, 0x0
05A3  2DCD     GOTO 0x5CD
288:                   {                         //the first tube, but for tubes 3-8
289:                       if (AnimBuf[Pos] != 0)
05A4  083E     MOVF Pos, W
05A5  3E20     ADDLW 0x20
05A6  0086     MOVWF FSR1
05A7  0187     CLRF FSR1H
05A8  0801     MOVF INDF1, W
05A9  1903     BTFSC STATUS, 0x2
05AA  2DC7     GOTO 0x5C7
290:                       {
291:                           AnimBuf[Pos]--;
05AB  083E     MOVF Pos, W
05AC  3E20     ADDLW 0x20
05AD  0086     MOVWF FSR1
05AE  0187     CLRF FSR1H
05AF  3001     MOVLW 0x1
05B0  0281     SUBWF INDF1, F
292:                           Action = 1;
05B1  167C     BSF NegWL, 0x4
293:                           DisplayBuf[Pos]++;
05B2  3001     MOVLW 0x1
05B3  00F2     MOVWF input
05B4  083E     MOVF Pos, W
05B5  3E3F     ADDLW 0x3F
05B6  0086     MOVWF FSR1
05B7  0187     CLRF FSR1H
05B8  0872     MOVF input, W
05B9  0781     ADDWF INDF1, F
294:                           if (DisplayBuf[Pos] == 10)
05BA  083E     MOVF Pos, W
05BB  3E3F     ADDLW 0x3F
05BC  0086     MOVWF FSR1
05BD  0187     CLRF FSR1H
05BE  300A     MOVLW 0xA
05BF  0601     XORWF INDF1, W
05C0  1D03     BTFSS STATUS, 0x2
05C1  2DC7     GOTO 0x5C7
295:                               DisplayBuf[Pos] = 0;
05C2  083E     MOVF Pos, W
05C3  3E3F     ADDLW 0x3F
05C4  0086     MOVWF FSR1
05C5  0187     CLRF FSR1H
05C6  0181     CLRF INDF1
296:                       }
297:                   }
05C7  3001     MOVLW 0x1
05C8  02BE     SUBWF Pos, F
05C9  3003     MOVLW 0x3
05CA  023E     SUBWF Pos, W
05CB  1803     BTFSC STATUS, 0x0
05CC  2DA4     GOTO 0x5A4
298:                   if (Action == 1) //if a tube has been changed, display it
05CD  1E7C     BTFSS NegWL, 0x4
05CE  2DD3     GOTO 0x5D3
299:                       Loader();
05CF  318E     MOVLP 0xE
05D0  266F     CALL 0x66F
05D1  3185     MOVLP 0x5
05D2  2DD5     GOTO 0x5D5
300:                   else if (Action == 0) //if no tubes changed then we are done
05D3  1E7C     BTFSS NegWL, 0x4
05D4  2DDF     GOTO 0x5DF
301:                       break;
302:                   _delay(debounce); //time for tube display
05D5  3015     MOVLW 0x15
05D6  00F2     MOVWF input
05D7  30C6     MOVLW 0xC6
05D8  0B89     DECFSZ WREG, F
05D9  2DD8     GOTO 0x5D8
05DA  0BF2     DECFSZ input, F
05DB  2DD8     GOTO 0x5D8
05DC  3200     BRA 0x5DD
05DD  0140     MOVLB 0x0
05DE  2D82     GOTO 0x582
303:               }
304:               Pulse(); //flash tubes at the end of the animation
05DF  318F     MOVLP 0xF
05E0  2742     CALL 0x742
305:           }
05E1  0008     RETURN
306:           
307:           void Pulse(void)
308:           {
309:               extern uint8_t Brightness; //pull in global brightness variable
310:               
311:               Brightness = 7; //flash full brightness
0F42  3007     MOVLW 0x7
0F43  00F1     MOVWF data
0F44  0871     MOVF data, W
0F45  00BB     MOVWF Brightness
312:               _delay(104000); //these lengths are based on looks
0F46  3088     MOVLW 0x88
0F47  00F1     MOVWF data
0F48  300F     MOVLW 0xF
0F49  0B89     DECFSZ WREG, F
0F4A  2F49     GOTO 0x749
0F4B  0BF1     DECFSZ data, F
0F4C  2F49     GOTO 0x749
0F4D  0000     NOP
313:               Brightness = 6; //level 6 brightness
0F4E  3006     MOVLW 0x6
0F4F  00F1     MOVWF data
0F50  0871     MOVF data, W
0F51  0140     MOVLB 0x0
0F52  00BB     MOVWF Brightness
314:               _delay(26000);
0F53  3022     MOVLW 0x22
0F54  00F1     MOVWF data
0F55  30C3     MOVLW 0xC3
0F56  0B89     DECFSZ WREG, F
0F57  2F56     GOTO 0x756
0F58  0BF1     DECFSZ data, F
0F59  2F56     GOTO 0x756
0F5A  0000     NOP
315:               Brightness = 5; //level 5 brightness
0F5B  3005     MOVLW 0x5
0F5C  00F1     MOVWF data
0F5D  0871     MOVF data, W
0F5E  0140     MOVLB 0x0
0F5F  00BB     MOVWF Brightness
316:               _delay(21000);
0F60  301C     MOVLW 0x1C
0F61  00F1     MOVWF data
0F62  3044     MOVLW 0x44
0F63  0B89     DECFSZ WREG, F
0F64  2F63     GOTO 0x763
0F65  0BF1     DECFSZ data, F
0F66  2F63     GOTO 0x763
0F67  3200     BRA 0xF68
317:               Brightness = 4; //level 4 brightness
0F68  3004     MOVLW 0x4
0F69  00F1     MOVWF data
0F6A  0871     MOVF data, W
0F6B  0140     MOVLB 0x0
0F6C  00BB     MOVWF Brightness
318:               _delay(16000);
0F6D  3015     MOVLW 0x15
0F6E  00F1     MOVWF data
0F6F  30C6     MOVLW 0xC6
0F70  0B89     DECFSZ WREG, F
0F71  2F70     GOTO 0x770
0F72  0BF1     DECFSZ data, F
0F73  2F70     GOTO 0x770
0F74  3200     BRA 0xF75
319:               Brightness = 3; //level 3 brightness
0F75  3003     MOVLW 0x3
0F76  00F1     MOVWF data
0F77  0871     MOVF data, W
0F78  0140     MOVLB 0x0
0F79  00BB     MOVWF Brightness
320:           }
0F7A  0008     RETURN
321:           
322:           void FixedWL(void)
323:           {
324:               for (Pos=8; Pos--;) //load a value for animation length for the tubes
0CC2  3008     MOVLW 0x8
0CC3  00DC     MOVWF 0x5C
0CC4  085C     MOVF 0x5C, W
0CC5  00BE     MOVWF Pos
325:               {
326:                   AnimBuf[Pos] = RunLength[RandomNum(63)]; //value loading for tubes
0CCB  303F     MOVLW 0x3F
0CCC  318C     MOVLP 0xC
0CCD  24FE     CALL 0x4FE
0CCE  318C     MOVLP 0xC
0CCF  3E20     ADDLW 0x20
0CD0  0086     MOVWF FSR1
0CD1  3001     MOVLW 0x1
0CD2  0087     MOVWF FSR1H
0CD3  0801     MOVF INDF1, W
0CD4  00DC     MOVWF 0x5C
0CD5  083E     MOVF Pos, W
0CD6  3E20     ADDLW 0x20
0CD7  0086     MOVWF FSR1
0CD8  0187     CLRF FSR1H
0CD9  085C     MOVF 0x5C, W
0CDA  0081     MOVWF INDF1
327:               }
0CC6  3001     MOVLW 0x1
0CC7  02BE     SUBWF Pos, F
0CC8  0A3E     INCF Pos, W
0CC9  1903     BTFSC STATUS, 0x2
0CCA  2CDC     GOTO 0x4DC
0CDB  2CC6     GOTO 0x4C6
328:               AnimBuf[1] = 0; //clear the value for the second tube, it is a fixed DP, done this way since it is more efficient
0CDC  01A1     CLRF 0x21
329:               AnimateFixed(); //run the animation that is now setup
0CDD  3185     MOVLP 0x5
0CDE  25E2     CALL 0x5E2
330:           }
0CDF  0008     RETURN
331:           
332:           void AnimateFixed(void)
333:           {
334:               while (1) //this will loop until all the numbers have settled
335:               {
336:                   Action = 0; //clear the flag
05E2  127C     BCF NegWL, 0x4
337:                   for (Pos=8; Pos--;) //this covers all tubes
05E3  3008     MOVLW 0x8
05E4  00F2     MOVWF input
05E5  0872     MOVF input, W
05E6  0140     MOVLB 0x0
05E7  00BE     MOVWF Pos
338:                   {
339:                       if (AnimBuf[Pos] != 0) //if the animation has not finished
05ED  083E     MOVF Pos, W
05EE  3E20     ADDLW 0x20
05EF  0086     MOVWF FSR1
05F0  0187     CLRF FSR1H
05F1  0801     MOVF INDF1, W
05F2  1903     BTFSC STATUS, 0x2
05F3  2DE8     GOTO 0x5E8
340:                       {
341:                           AnimBuf[Pos]--; //decrement the animation counter
05F4  083E     MOVF Pos, W
05F5  3E20     ADDLW 0x20
05F6  0086     MOVWF FSR1
05F7  0187     CLRF FSR1H
05F8  3001     MOVLW 0x1
05F9  0281     SUBWF INDF1, F
342:                           if (AnimBuf[Pos] == 0) //if the animation is now done
05FA  083E     MOVF Pos, W
05FB  3E20     ADDLW 0x20
05FC  0086     MOVWF FSR1
05FD  0187     CLRF FSR1H
05FE  0801     MOVF INDF1, W
05FF  1D03     BTFSS STATUS, 0x2
0600  2E0E     GOTO 0x60E
343:                           {
344:                               DisplayBuf[Pos] = DisplaySave[Pos]; //get the right value in the buffer, the animation does not land on the right one
0601  083E     MOVF Pos, W
0602  3EBD     ADDLW 0xBD
0603  0086     MOVWF FSR1
0604  0187     CLRF FSR1H
0605  0801     MOVF INDF1, W
0606  00F2     MOVWF input
0607  083E     MOVF Pos, W
0608  3E3F     ADDLW 0x3F
0609  0086     MOVWF FSR1
060A  0187     CLRF FSR1H
060B  0872     MOVF input, W
060C  0081     MOVWF INDF1
345:                               continue; //end this loop, this does not count as an animation
060D  2DE8     GOTO 0x5E8
346:                           }
347:                           else
348:                           {
349:                               Action = 1; //set flag
060E  167C     BSF NegWL, 0x4
350:                               DisplayBuf[Pos]++; //increment the display
060F  3001     MOVLW 0x1
0610  00F2     MOVWF input
0611  083E     MOVF Pos, W
0612  3E3F     ADDLW 0x3F
0613  0086     MOVWF FSR1
0614  0187     CLRF FSR1H
0615  0872     MOVF input, W
0616  0781     ADDWF INDF1, F
351:                               if (DisplayBuf[Pos] == 10) //if display gets to 10
0617  083E     MOVF Pos, W
0618  3E3F     ADDLW 0x3F
0619  0086     MOVWF FSR1
061A  0187     CLRF FSR1H
061B  300A     MOVLW 0xA
061C  0601     XORWF INDF1, W
061D  1D03     BTFSS STATUS, 0x2
061E  2DE8     GOTO 0x5E8
352:                                   DisplayBuf[Pos] = 0; //wrap to 0
061F  083E     MOVF Pos, W
0620  3E3F     ADDLW 0x3F
0621  0086     MOVWF FSR1
0622  0187     CLRF FSR1H
0623  0181     CLRF INDF1
353:                           }
354:                       }
355:                   }
05E8  3001     MOVLW 0x1
05E9  02BE     SUBWF Pos, F
05EA  0A3E     INCF Pos, W
05EB  1903     BTFSC STATUS, 0x2
05EC  2E25     GOTO 0x625
0624  2DE8     GOTO 0x5E8
356:                   if (Action == 1) //if a tube has been changed, display it
0625  1E7C     BTFSS NegWL, 0x4
0626  2E2B     GOTO 0x62B
357:                       Loader();
0627  318E     MOVLP 0xE
0628  266F     CALL 0x66F
0629  3185     MOVLP 0x5
062A  2E2D     GOTO 0x62D
358:                   else if (Action == 0) //if no tubes changed then we are done
062B  1E7C     BTFSS NegWL, 0x4
062C  2E37     GOTO 0x637
359:                       break;
360:                   _delay(debounce); //time for tube display
062D  3015     MOVLW 0x15
062E  00F2     MOVWF input
062F  30C6     MOVLW 0xC6
0630  0B89     DECFSZ WREG, F
0631  2E30     GOTO 0x630
0632  0BF2     DECFSZ input, F
0633  2E30     GOTO 0x630
0634  3200     BRA 0x635
0635  0140     MOVLB 0x0
0636  2DE2     GOTO 0x5E2
361:               }
362:               Pulse(); //flash tubes at the end of the animation
0637  318F     MOVLP 0xF
0638  2742     CALL 0x742
363:           }
0639  0008     RETURN
364:           
365:           void DisplayBufSave(void)
366:           {
367:               for (Pos=8; Pos--;) //this will loop until all values in the display buffer are 10, a number that will not display anything
0BC7  3008     MOVLW 0x8
0BC8  00F1     MOVWF data
0BC9  0871     MOVF data, W
0BCA  00BE     MOVWF Pos
368:               {
369:                   DisplaySave[Pos] = DisplayBuf[Pos]; //change current value to 10
0BD0  083E     MOVF Pos, W
0BD1  3E3F     ADDLW 0x3F
0BD2  0086     MOVWF FSR1
0BD3  0187     CLRF FSR1H
0BD4  0801     MOVF INDF1, W
0BD5  00F1     MOVWF data
0BD6  083E     MOVF Pos, W
0BD7  3EBD     ADDLW 0xBD
0BD8  0086     MOVWF FSR1
0BD9  0187     CLRF FSR1H
0BDA  0871     MOVF data, W
0BDB  0081     MOVWF INDF1
370:               }
0BCB  3001     MOVLW 0x1
0BCC  02BE     SUBWF Pos, F
0BCD  0A3E     INCF Pos, W
0BCE  1903     BTFSC STATUS, 0x2
0BCF  0008     RETURN
0BDC  2BCB     GOTO 0x3CB
371:           }
372:           
373:           void Loader(void)
374:           {
375:               char regp; //for counter
376:               char shftregpln[12] = {L,1,2,3,4,5,6,7,8,9,0,R}; //this is the order of the inputs into the tube as setup on the board
0E6F  30C5     MOVLW 0xC5
0E70  0086     MOVWF FSR1
0E71  3000     MOVLW 0x0
0E72  0087     MOVWF FSR1H
0E73  304B     MOVLW 0x4B
0E74  0084     MOVWF FSR0
0E75  3000     MOVLW 0x0
0E76  0085     MOVWF FSR0H
0E77  300C     MOVLW 0xC
0E78  00F1     MOVWF data
0E79  0016     MOVIW FSR1++
0E7A  001A     MOVWI FSR0++
0E7B  0BF1     DECFSZ data, F
0E7C  2E79     GOTO 0x679
377:               
378:               for (Pos=0; Pos<8; Pos++) //this will rotate through all the tubes, 
0E7D  0140     MOVLB 0x0
0E7E  01BE     CLRF Pos
0E7F  3008     MOVLW 0x8
0E80  023E     SUBWF Pos, W
0E81  1803     BTFSC STATUS, 0x0
0E82  0008     RETURN
379:               { //cant use any fancy c compiler tricks for space saving, this must be done in order
380:                   for (regp=0; regp<13; regp++) //this will check where the 1 needs to be to display the value correctly
0E83  01D7     CLRF regp
381:                   {
382:                       if (shftregpln[regp] == DisplayBuf[Pos]) //the actual search check
0E84  083E     MOVF Pos, W
0E85  3E3F     ADDLW 0x3F
0E86  0086     MOVWF FSR1
0E87  0187     CLRF FSR1H
0E88  0857     MOVF regp, W
0E89  3E4B     ADDLW 0x4B
0E8A  0084     MOVWF FSR0
0E8B  0185     CLRF FSR0H
0E8C  0800     MOVF INDF0, W
0E8D  0601     XORWF INDF1, W
0E8E  1D03     BTFSS STATUS, 0x2
0E8F  2E92     GOTO 0x692
383:                       {
384:                           //LATC |= 0b0010100; //setup the 1 to be sent over the DAT line
385:                           DIN_SetHigh(); //set DIN high to send a 1
0E90  169A     BSF LATC, 0x5
0E91  2E93     GOTO 0x693
386:                           CLK_SetHigh(); //raise the CLK line
387:                           CLK_SetLow(); //flip the CLK line to create a voltage drop and the 1 is read by the shift register
388:                       }
389:                       else
390:                       {
391:                           DIN_SetLow(); //ensure that DIN is low a 1 wont be sent
0E92  129A     BCF LATC, 0x5
392:                           CLK_SetHigh(); //raise the CLK line
0E93  159A     BSF LATC, 0x3
393:                           CLK_SetLow(); //flip the CLK line to create a voltage drop and the 0 is read by the shift register
0E94  119A     BCF LATC, 0x3
394:                       }
395:                   }
0E95  3001     MOVLW 0x1
0E96  00F1     MOVWF data
0E97  0871     MOVF data, W
0E98  07D7     ADDWF regp, F
0E99  300D     MOVLW 0xD
0E9A  0257     SUBWF regp, W
0E9B  1C03     BTFSS STATUS, 0x0
0E9C  2E84     GOTO 0x684
396:               }
0E9D  3001     MOVLW 0x1
0E9E  00F1     MOVWF data
0E9F  0871     MOVF data, W
0EA0  07BE     ADDWF Pos, F
397:           }
398:           
399:           void EEPROMBufferFill(uint8_t addr)
0C53  00F3     MOVWF addr
400:           {
401:               for (Pos=8; Pos--;) //loading a number to the display so there is something to look at while waiting for button presses
0C54  3008     MOVLW 0x8
0C55  00F2     MOVWF input
0C56  0872     MOVF input, W
0C57  0140     MOVLB 0x0
0C58  00BE     MOVWF Pos
402:               {
403:                   DisplayBuf[Pos] = EEPROM_Read(addr); //get a number from the EEPROM
0C5E  0873     MOVF addr, W
0C5F  318A     MOVLP 0xA
0C60  2263     CALL 0x263
0C61  318C     MOVLP 0xC
0C62  00F2     MOVWF input
0C63  0140     MOVLB 0x0
0C64  083E     MOVF Pos, W
0C65  3E3F     ADDLW 0x3F
0C66  0086     MOVWF FSR1
0C67  0187     CLRF FSR1H
0C68  0872     MOVF input, W
0C69  0081     MOVWF INDF1
404:                   addr--; //move to the next number in EEPROM
0C6A  3001     MOVLW 0x1
0C6B  02F3     SUBWF addr, F
405:               }
0C59  3001     MOVLW 0x1
0C5A  02BE     SUBWF Pos, F
0C5B  0A3E     INCF Pos, W
0C5C  1903     BTFSC STATUS, 0x2
0C5D  0008     RETURN
0C6C  2C59     GOTO 0x459
406:           }
---  C:/Users/Nicholas/AppData/Local/Temp/xcAscr0.s  ----------------------------------------------------
0A33  00FE     MOVWF 0x7E
0A34  0012     MOVIW FSR0++
0A35  001E     MOVWI FSR1++
0A36  0BFE     DECFSZ 0x7E, F
0A37  2A34     GOTO 0x234
0A38  3400     RETLW 0x0
0019  3189     MOVLP 0x9
001C  00EC     MOVWF __pdataBANK0
001D  30DF     MOVLW 0xDF
001E  0084     MOVWF FSR0
001F  308A     MOVLW 0x8A
0020  0085     MOVWF FSR0H
0021  30C5     MOVLW 0xC5
0022  0086     MOVWF FSR1
0023  3000     MOVLW 0x0
0024  0087     MOVWF FSR1H
0025  300C     MOVLW 0xC
0026  318A     MOVLP 0xA
0029  307B     MOVLW 0x7B
002A  0084     MOVWF FSR0
002B  308F     MOVLW 0x8F
002C  0085     MOVWF FSR0H
002D  3020     MOVLW 0x20
002E  0086     MOVWF FSR1
002F  3001     MOVLW 0x1
0030  0087     MOVWF FSR1H
0031  3040     MOVLW 0x40
0032  318A     MOVLP 0xA
0A2D  0064     CLRWDT
0A2E  0180     CLRF INDF0
0A2F  3101     ADDFSR 0, 1
0A30  0B89     DECFSZ WREG, F
0A31  2A2E     GOTO 0x22E
0A32  3400     RETLW 0x0
0035  01FC     CLRF NegWL
0036  3020     MOVLW 0x20
0037  0084     MOVWF FSR0
0038  3000     MOVLW 0x0
0039  0085     MOVWF FSR0H
003A  302B     MOVLW 0x2B
003B  318A     MOVLP 0xA
003E  30A0     MOVLW 0xA0
003F  0084     MOVWF FSR0
0040  3000     MOVLW 0x0
0041  0085     MOVWF FSR0H
0042  3025     MOVLW 0x25
0043  318A     MOVLP 0xA
0045  107E     BCF 0x7E, 0x0
0046  0140     MOVLB 0x0
0047  3180     MOVLP 0x0
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/pic/__eeprom.c  -------------------------------
1:             #include	<xc.h>	
2:             
3:             #if 	EEPROM_SIZE > 0
4:             
5:             void
6:             __eecpymem(volatile unsigned char *to, __eeprom unsigned char * from, unsigned char size)
0D20  00F5     MOVWF idx
7:             {
8:             	volatile unsigned char *cp = to;
0D21  0875     MOVF idx, W
0D22  00F3     MOVWF addr
0D23  0873     MOVF addr, W
0D24  00F4     MOVWF buffer
9:             #if _EEPROM_INT == _EEREG_INT
10:            	while (EECON1bits.WR) continue;
11:            	EEADR = (unsigned char)from;
12:            	while(size--) {
13:            		while (EECON1bits.WR) continue;
14:            		#ifdef	__FLASHTYPE
15:            		EECON1 &= 0x7F;
16:            		#endif
17:            		EECON1bits.RD = 1;
18:            		*cp++ = EEDATA;
19:            		++EEADR;
20:            	}
21:            #elif _EEPROM_INT == _NVMREG_INT
22:            	while (NVMCON1bits.WR) {
23:            		continue;
24:            	}
0D25  0150     MOVLB 0x10
0D26  189E     BTFSC NVMCON1, 0x1
0D27  2D25     GOTO 0x525
25:            	NVMCON1bits.NVMREGS = 1;
0D28  171E     BSF NVMCON1, 0x6
26:            	NVMADRL = (unsigned char) from;
0D29  0871     MOVF 0x871, W
0D2A  009A     MOVWF NVMADR
27:            	NVMADRH = 0x70;
0D2B  3070     MOVLW 0x70
0D2C  009B     MOVWF NVMADRH
28:            	while (size--) {
0D2D  3001     MOVLW 0x1
0D2E  02F2     SUBWF 0x872, F
0D2F  0A72     INCF 0x872, W
0D30  1903     BTFSC STATUS, 0x2
0D31  0008     RETURN
0D42  2D2D     GOTO 0x52D
29:            		NVMCON1bits.RD = 1;
0D32  141E     BSF NVMCON1, 0x0
30:            		*cp++ = NVMDATL;
0D33  081C     MOVF NVMDAT, W
0D34  00F3     MOVWF 0x873
0D35  0874     MOVF 0x874, W
0D36  0086     MOVWF FSR1L
0D37  0187     CLRF FSR1H
0D38  0873     MOVF 0x873, W
0D39  0081     MOVWF INDF1
0D3A  3001     MOVLW 0x1
0D3B  00F3     MOVWF 0x873
0D3C  0873     MOVF 0x873, W
0D3D  07F4     ADDWF 0x874, F
31:            		NVMADRL++;
0D3E  3001     MOVLW 0x1
0D3F  00F3     MOVWF 0x873
0D40  0873     MOVF 0x873, W
0D41  079A     ADDWF NVMADR, F
32:            	}
33:            #else
34:            #error "Unknonwn EEPROM register interface"
35:            #endif
36:            }
37:            
38:            void
39:            __memcpyee(__eeprom unsigned char * to, const unsigned char *from, unsigned char size)
40:            {
41:            	const unsigned char *ptr =from;
42:            #if _EEPROM_INT == _EEREG_INT
43:            	while (EECON1bits.WR) continue;
44:            	EEADR = (unsigned char)to - 1U;
45:            	#ifdef	__FLASHTYPE
46:            	EECON1 &= 0x7F;
47:            	#endif
48:            	while(size--) {
49:            		while (EECON1bits.WR) { 
50:            			continue;
51:            		}
52:            		EEDATA = *ptr++;
53:            		++EEADR;
54:            		STATUSbits.CARRY = 0; 
55:            		if (INTCONbits.GIE) {
56:            			STATUSbits.CARRY = 1; 
57:            		}
58:            		INTCONbits.GIE = 0;
59:            		EECON1bits.WREN = 1;
60:            		EECON2 = 0x55;
61:            		EECON2 = 0xAA;
62:            		EECON1bits.WR = 1;
63:            		EECON1bits.WREN = 0;
64:            		if (STATUSbits.CARRY) {
65:            			INTCONbits.GIE = 1;	//an opportunity for interrupts to happen
66:            		}
67:            	}
68:            #elif _EEPROM_INT == _NVMREG_INT
69:            	while (NVMCON1bits.WR) {
70:            		continue;
71:            	}
72:            	NVMCON1bits.NVMREGS = 1;
73:            	NVMADRL = (unsigned char) to - 1U;
74:            	NVMADRH = 0x70;
75:            	NVMDATH = 0;
76:            	while (size--) {
77:            		while (NVMCON1bits.WR) {
78:            			continue;
79:            		}
80:            		NVMDATL = *ptr++;
81:            		NVMADRL++;
82:            		STATUSbits.CARRY = 0;
83:            		if (INTCONbits.GIE) {
84:            			STATUSbits.CARRY = 1;
85:            		}
86:            		NVMCON1bits.WREN = 1;
87:            		NVMCON2 = 0x55;
88:            		NVMCON2 = 0xAA;
89:            		NVMCON1bits.WR = 1;
90:            		while (NVMCON1bits.WR) {
91:            			continue;
92:            		}
93:            		NVMCON1bits.WREN = 0;
94:            		if (STATUSbits.CARRY) {
95:            			INTCONbits.GIE = 1;
96:            		}
97:            	}
98:            #else
99:            #error "Unknonwn EEPROM register interface"
100:           #endif
101:           }
102:           
103:           unsigned char
104:           __eetoc(__eeprom void *addr)
0AD3  00F8     MOVWF 0x878
105:           {
106:           	unsigned char data;
107:           	__eecpymem((unsigned char *) &data,addr,1);
0AD4  0878     MOVF 0x878, W
0AD5  00F6     MOVWF 0x876
0AD6  0876     MOVF 0x876, W
0AD7  00F1     MOVWF 0x871
0AD8  01F2     CLRF 0x872
0AD9  0AF2     INCF 0x872, F
0ADA  3077     MOVLW 0x77
0ADB  318D     MOVLP 0xD
0ADC  2520     CALL 0x520
108:           	return data;
0ADD  0877     MOVF 0x877, W
109:           }
0ADE  0008     RETURN
110:           
111:           unsigned int
112:           __eetoi(__eeprom void *addr)
0BA0  0140     MOVLB 0x0
0BA1  00CB     MOVWF __pcstackBANK0
113:           {
114:           	unsigned int data;
115:           	__eecpymem((unsigned char *) &data,addr,2);
0BA2  084B     MOVF __pcstackBANK0, W
0BA3  00F8     MOVWF readVal
0BA4  0878     MOVF readVal, W
0BA5  00F1     MOVWF data
0BA6  3002     MOVLW 0x2
0BA7  00F9     MOVWF dividend
0BA8  0879     MOVF dividend, W
0BA9  00F2     MOVWF input
0BAA  304C     MOVLW 0x4C
0BAB  318D     MOVLP 0xD
0BAC  2520     CALL 0x520
116:           	return data;
0BAD  0140     MOVLB 0x0
0BAE  084D     MOVF quotient, W
0BAF  00F7     MOVWF divisor
0BB0  084C     MOVF sign, W
0BB1  00F6     MOVWF cb
117:           }
0BB2  0008     RETURN
118:           
119:           #pragma warning push
120:           #pragma warning disable 2040
121:           __uint24
122:           __eetom(__eeprom void *addr)
123:           {
124:           	__uint24 data;
125:           	__eecpymem((unsigned char *) &data,addr,3);
126:           	return data;
127:           }
128:           #pragma warning pop
129:           
130:           unsigned long
131:           __eetol(__eeprom void *addr)
132:           {
133:           	unsigned long data;
134:           	__eecpymem((unsigned char *) &data,addr,4);
135:           	return data;
136:           }
137:           
138:           #pragma warning push
139:           #pragma warning disable 1516
140:           unsigned long long
141:           __eetoo(__eeprom void *addr)
142:           {
143:           	unsigned long long data;
144:           	__eecpymem((unsigned char *) &data,addr,8);
145:           	return data;
146:           }
147:           #pragma warning pop
148:           
149:           unsigned char
150:           __ctoee(__eeprom void *addr, unsigned char data)
151:           {
152:           	__memcpyee(addr,(unsigned char *) &data,1);
153:           	return data;
154:           }
155:           
156:           unsigned int
157:           __itoee(__eeprom void *addr, unsigned int data)
158:           {
159:           	__memcpyee(addr,(unsigned char *) &data,2);
160:           	return data;
161:           }
162:           
163:           #pragma warning push
164:           #pragma warning disable 2040
165:           __uint24
166:           __mtoee(__eeprom void *addr, __uint24 data)
167:           {
168:           	__memcpyee(addr,(unsigned char *) &data,3);
169:           	return data;
170:           }
171:           #pragma warning pop
172:           
173:           unsigned long
174:           __ltoee(__eeprom void *addr, unsigned long data)
175:           {
176:           	__memcpyee(addr,(unsigned char *) &data,4);
177:           	return data;
178:           }
179:           
180:           #pragma warning push
181:           #pragma warning disable 1516
182:           unsigned long long
183:           __otoee(__eeprom void *addr, unsigned long long data)
184:           {
185:           	__memcpyee(addr,(unsigned char *) &data,8);
186:           	return data;
187:           }
188:           #pragma warning pop
189:           
190:           float
191:           __eetoft(__eeprom void *addr)
192:           {
193:           	float data;
194:           	__eecpymem((unsigned char *) &data,addr,3);
195:           	return data;
196:           }
197:           
198:           double
199:           __eetofl(__eeprom void *addr)
200:           {
201:           	double data;
202:           	__eecpymem((unsigned char *) &data,addr,4);
203:           	return data;
204:           }
205:           
206:           float
207:           __fttoee(__eeprom void *addr, float data)
208:           {
209:           	__memcpyee(addr,(unsigned char *) &data,3);
210:           	return data;
211:           }
212:           
213:           double
214:           __fltoee(__eeprom void *addr, double data)
215:           {
216:           	__memcpyee(addr,(unsigned char *) &data,4);
217:           	return data;
218:           }
219:           #endif
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/rand.c  --------------------------------
1:             #include <stdlib.h>
2:             #include <stdint.h>
3:             
4:             static uint32_t seed;
5:             
6:             void srand(unsigned int s)
7:             {
8:             	seed = s-1;
0A48  084B     MOVF __pcstackBANK0, W
0A49  3EFF     ADDLW 0xFF
0A4A  00C7     MOVWF seed
0A4B  30FF     MOVLW 0xFF
0A4C  3D4C     ADDWFC sign, W
0A4D  00C8     MOVWF 0x48
0A4E  01C9     CLRF 0x49
0A4F  01CA     CLRF 0x4A
9:             }
0A50  0008     RETURN
10:            
11:            int rand(void)
12:            {
13:            	seed = 1284865837UL*seed + 1;
0EA2  084A     MOVF 0x4A, W
0EA3  00F4     MOVWF buffer
0EA4  0849     MOVF 0x49, W
0EA5  00F3     MOVWF addr
0EA6  0848     MOVF 0x48, W
0EA7  00F2     MOVWF input
0EA8  0847     MOVF seed, W
0EA9  00F1     MOVWF data
0EAA  304C     MOVLW 0x4C
0EAB  00F8     MOVWF readVal
0EAC  3095     MOVLW 0x95
0EAD  00F7     MOVWF divisor
0EAE  307F     MOVLW 0x7F
0EAF  00F6     MOVWF cb
0EB0  302D     MOVLW 0x2D
0EB1  00F5     MOVWF idx
0EB2  318E     MOVLP 0xE
0EB3  2611     CALL 0x611
0EB4  318E     MOVLP 0xE
0EB5  3001     MOVLW 0x1
0EB6  0771     ADDWF data, W
0EB7  00C7     MOVWF seed
0EB8  3000     MOVLW 0x0
0EB9  3D72     ADDWFC input, W
0EBA  00C8     MOVWF 0x48
0EBB  3000     MOVLW 0x0
0EBC  3D73     ADDWFC addr, W
0EBD  00C9     MOVWF 0x49
0EBE  3000     MOVLW 0x0
0EBF  3D74     ADDWFC buffer, W
0EC0  00CA     MOVWF 0x4A
14:            	return (int)(unsigned int)(seed >> 17);
0EC1  0847     MOVF seed, W
0EC2  00D1     MOVWF read
0EC3  0848     MOVF 0x48, W
0EC4  00D2     MOVWF returnValue
0EC5  0849     MOVF 0x49, W
0EC6  00D3     MOVWF reg
0EC7  084A     MOVF 0x4A, W
0EC8  00D4     MOVWF data
0EC9  3011     MOVLW 0x11
0ECA  36D4     LSRF data, F
0ECB  0CD3     RRF reg, F
0ECC  0CD2     RRF returnValue, F
0ECD  0CD1     RRF read, F
0ECE  0B89     DECFSZ WREG, F
0ECF  2ECA     GOTO 0x6CA
0ED0  0852     MOVF returnValue, W
0ED1  00D0     MOVWF 0x50
0ED2  0851     MOVF read, W
0ED3  00CF     MOVWF dutyValue
15:            }
0ED4  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/awmod.c  -------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awmod(signed int divisor, signed int dividend)
6:             #else
7:             __awmod(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
0FBB  01FB     CLRF readValHigh
13:            	if(dividend < 0) {
0FBC  1FD8     BTFSS min, 0x7
0FBD  2FC5     GOTO 0x7C5
14:            		dividend = -dividend;
0FBE  09D7     COMF regp, F
0FBF  09D8     COMF min, F
0FC0  0AD7     INCF regp, F
0FC1  1903     BTFSC STATUS, 0x2
0FC2  0AD8     INCF min, F
15:            		sign = 1;
0FC3  01FB     CLRF readValHigh
0FC4  0AFB     INCF readValHigh, F
16:            	}
17:            	if(divisor < 0)
0FC5  1FD6     BTFSS e, 0x7
0FC6  2FCC     GOTO 0x7CC
18:            		divisor = -divisor;
0FC7  09D5     COMF divisor, F
0FC8  09D6     COMF e, F
0FC9  0AD5     INCF divisor, F
0FCA  1903     BTFSC STATUS, 0x2
0FCB  0AD6     INCF e, F
19:            	if(divisor != 0) {
0FCC  0855     MOVF divisor, W
0FCD  0456     IORWF e, W
0FCE  1903     BTFSC STATUS, 0x2
0FCF  2FF3     GOTO 0x7F3
20:            		counter = 1;
0FD0  01FA     CLRF readValLow
0FD1  0AFA     INCF readValLow, F
21:            		while(((unsigned int)divisor & 0x8000U) == 0) {
0FD2  1BD6     BTFSC e, 0x7
0FD3  2FDE     GOTO 0x7DE
0FDD  2FD2     GOTO 0x7D2
22:            			divisor <<= 1;
0FD4  3001     MOVLW 0x1
0FD5  35D5     LSLF divisor, F
0FD6  0DD6     RLF e, F
0FD7  0B89     DECFSZ WREG, F
0FD8  2FD5     GOTO 0x7D5
23:            			counter++;
0FD9  3001     MOVLW 0x1
0FDA  00F9     MOVWF dividend
0FDB  0879     MOVF dividend, W
0FDC  07FA     ADDWF readValLow, F
24:            		}
25:            		do {
26:            			if((unsigned int)divisor <= (unsigned int)dividend)
0FDE  0856     MOVF e, W
0FDF  0258     SUBWF min, W
0FE0  1D03     BTFSS STATUS, 0x2
0FE1  2FE4     GOTO 0x7E4
0FE2  0855     MOVF divisor, W
0FE3  0257     SUBWF regp, W
0FE4  1C03     BTFSS STATUS, 0x0
0FE5  2FEA     GOTO 0x7EA
27:            				dividend -= divisor;
0FE6  0855     MOVF divisor, W
0FE7  02D7     SUBWF regp, F
0FE8  0856     MOVF e, W
0FE9  3BD8     SUBWFB min, F
28:            			*(unsigned int *)&divisor >>= 1;
0FEA  3001     MOVLW 0x1
0FEB  36D6     LSRF e, F
0FEC  0CD5     RRF divisor, F
0FED  0B89     DECFSZ WREG, F
0FEE  2FEB     GOTO 0x7EB
29:            		} while(--counter != 0);
0FEF  3001     MOVLW 0x1
0FF0  02FA     SUBWF readValLow, F
0FF1  1D03     BTFSS STATUS, 0x2
0FF2  2FDE     GOTO 0x7DE
30:            	}
31:            	if(sign)
0FF3  087B     MOVF readValHigh, W
0FF4  1903     BTFSC STATUS, 0x2
0FF5  2FFB     GOTO 0x7FB
32:            		dividend = -dividend;
0FF6  09D7     COMF regp, F
0FF7  09D8     COMF min, F
0FF8  0AD7     INCF regp, F
0FF9  1903     BTFSC STATUS, 0x2
0FFA  0AD8     INCF min, F
33:            	return dividend;
0FFB  0858     MOVF min, W
0FFC  00D6     MOVWF e
0FFD  0857     MOVF regp, W
0FFE  00D5     MOVWF divisor
34:            }
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/awdiv.c  -------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
063A  01CC     CLRF sign
14:            	if(divisor < 0) {
063B  1FF8     BTFSS readVal, 0x7
063C  2E44     GOTO 0x644
15:            		divisor = -divisor;
063D  09F7     COMF divisor, F
063E  09F8     COMF readVal, F
063F  0AF7     INCF divisor, F
0640  1903     BTFSC STATUS, 0x2
0641  0AF8     INCF readVal, F
16:            		sign = 1;
0642  01CC     CLRF sign
0643  0ACC     INCF sign, F
17:            	}
18:            	if(dividend < 0) {
0644  1FFA     BTFSS readValLow, 0x7
0645  2E4F     GOTO 0x64F
19:            		dividend = -dividend;
0646  09F9     COMF dividend, F
0647  09FA     COMF readValLow, F
0648  0AF9     INCF dividend, F
0649  1903     BTFSC STATUS, 0x2
064A  0AFA     INCF readValLow, F
20:            		sign ^= 1;
064B  3001     MOVLW 0x1
064C  00FB     MOVWF readValHigh
064D  087B     MOVF readValHigh, W
064E  06CC     XORWF sign, F
21:            	}
22:            	quotient = 0;
064F  01CD     CLRF quotient
0650  01CE     CLRF 0x4E
23:            	if(divisor != 0) {
0651  0877     MOVF divisor, W
0652  0478     IORWF readVal, W
0653  1903     BTFSC STATUS, 0x2
0654  2E7E     GOTO 0x67E
24:            		counter = 1;
0655  01CB     CLRF __pcstackBANK0
0656  0ACB     INCF __pcstackBANK0, F
25:            		while(((unsigned int)divisor & 0x8000U) == 0) {
0657  1BF8     BTFSC readVal, 0x7
0658  2E63     GOTO 0x663
0662  2E57     GOTO 0x657
26:            			divisor <<= 1;
0659  3001     MOVLW 0x1
065A  35F7     LSLF divisor, F
065B  0DF8     RLF readVal, F
065C  0B89     DECFSZ WREG, F
065D  2E5A     GOTO 0x65A
27:            			counter++;
065E  3001     MOVLW 0x1
065F  00FB     MOVWF readValHigh
0660  087B     MOVF readValHigh, W
0661  07CB     ADDWF __pcstackBANK0, F
28:            		}
29:            		do {
30:            			quotient <<= 1;
0663  3001     MOVLW 0x1
0664  35CD     LSLF quotient, F
0665  0DCE     RLF 0x4E, F
0666  0B89     DECFSZ WREG, F
0667  2E64     GOTO 0x664
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0668  0878     MOVF readVal, W
0669  027A     SUBWF readValLow, W
066A  1D03     BTFSS STATUS, 0x2
066B  2E6E     GOTO 0x66E
066C  0877     MOVF divisor, W
066D  0279     SUBWF dividend, W
066E  1C03     BTFSS STATUS, 0x0
066F  2E75     GOTO 0x675
32:            				dividend -= divisor;
0670  0877     MOVF divisor, W
0671  02F9     SUBWF dividend, F
0672  0878     MOVF readVal, W
0673  3BFA     SUBWFB readValLow, F
33:            				quotient |= 1;
0674  144D     BSF quotient, 0x0
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
0675  3001     MOVLW 0x1
0676  36F8     LSRF readVal, F
0677  0CF7     RRF divisor, F
0678  0B89     DECFSZ WREG, F
0679  2E76     GOTO 0x676
36:            		} while(--counter != 0);
067A  3001     MOVLW 0x1
067B  02CB     SUBWF __pcstackBANK0, F
067C  1D03     BTFSS STATUS, 0x2
067D  2E63     GOTO 0x663
37:            	}
38:            	if(sign)
067E  084C     MOVF sign, W
067F  1903     BTFSC STATUS, 0x2
0680  2E86     GOTO 0x686
39:            		quotient = -quotient;
0681  09CD     COMF quotient, F
0682  09CE     COMF 0x4E, F
0683  0ACD     INCF quotient, F
0684  1903     BTFSC STATUS, 0x2
0685  0ACE     INCF 0x4E, F
40:            	return quotient;
0686  084E     MOVF 0x4E, W
0687  00F8     MOVWF readVal
0688  084D     MOVF quotient, W
0689  00F7     MOVWF divisor
41:            }
068A  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/Umul32.c  ------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
0E11  3000     MOVLW 0x0
0E12  00CE     MOVWF 0x4E
0E13  3000     MOVLW 0x0
0E14  00CD     MOVWF quotient
0E15  3000     MOVLW 0x0
0E16  00CC     MOVWF sign
0E17  3000     MOVLW 0x0
0E18  00CB     MOVWF __pcstackBANK0
120:           	do {
121:           		if(multiplier & 1)
0E19  1C71     BTFSS data, 0x0
0E1A  2E23     GOTO 0x623
122:           			product += multiplicand;
0E1B  0875     MOVF idx, W
0E1C  07CB     ADDWF __pcstackBANK0, F
0E1D  0876     MOVF cb, W
0E1E  3DCC     ADDWFC sign, F
0E1F  0877     MOVF divisor, W
0E20  3DCD     ADDWFC quotient, F
0E21  0878     MOVF readVal, W
0E22  3DCE     ADDWFC 0x4E, F
123:           		multiplicand <<= 1;
0E23  3001     MOVLW 0x1
0E24  35F5     LSLF idx, F
0E25  0DF6     RLF cb, F
0E26  0DF7     RLF divisor, F
0E27  0DF8     RLF readVal, F
0E28  0B89     DECFSZ WREG, F
0E29  2E24     GOTO 0x624
124:           		multiplier >>= 1;
0E2A  3001     MOVLW 0x1
0E2B  36F4     LSRF buffer, F
0E2C  0CF3     RRF addr, F
0E2D  0CF2     RRF input, F
0E2E  0CF1     RRF data, F
0E2F  0B89     DECFSZ WREG, F
0E30  2E2B     GOTO 0x62B
125:           	} while(multiplier != 0);
0E31  0874     MOVF buffer, W
0E32  0473     IORWF addr, W
0E33  0472     IORWF input, W
0E34  0471     IORWF data, W
0E35  1D03     BTFSS STATUS, 0x2
0E36  2E19     GOTO 0x619
126:           
127:           #endif
128:           	return product;
0E37  084E     MOVF 0x4E, W
0E38  00F4     MOVWF buffer
0E39  084D     MOVF quotient, W
0E3A  00F3     MOVWF addr
0E3B  084C     MOVF sign, W
0E3C  00F2     MOVWF input
0E3D  084B     MOVF __pcstackBANK0, W
0E3E  00F1     MOVWF data
129:           }
0E3F  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/Umul16.c  ------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (unsigned int)(LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (unsigned int)(HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
0C6D  01F5     CLRF idx
0C6E  01F6     CLRF cb
44:            	do {
45:            		if(multiplier & 1)
0C6F  1C71     BTFSS data, 0x0
0C70  2C75     GOTO 0x475
46:            			product += multiplicand;
0C71  0873     MOVF addr, W
0C72  07F5     ADDWF idx, F
0C73  0874     MOVF buffer, W
0C74  3DF6     ADDWFC cb, F
47:            		multiplicand <<= 1;
0C75  3001     MOVLW 0x1
0C76  35F3     LSLF addr, F
0C77  0DF4     RLF buffer, F
0C78  0B89     DECFSZ WREG, F
0C79  2C76     GOTO 0x476
48:            		multiplier >>= 1;
0C7A  3001     MOVLW 0x1
0C7B  36F2     LSRF input, F
0C7C  0CF1     RRF data, F
0C7D  0B89     DECFSZ WREG, F
0C7E  2C7B     GOTO 0x47B
49:            	} while(multiplier != 0);
0C7F  0871     MOVF data, W
0C80  0472     IORWF input, W
0C81  1D03     BTFSS STATUS, 0x2
0C82  2C6F     GOTO 0x46F
50:            
51:            #endif
52:                    return product;
0C83  0876     MOVF cb, W
0C84  00F2     MOVWF input
0C85  0875     MOVF idx, W
0C86  00F1     MOVWF data
53:            }
0C87  0008     RETURN
